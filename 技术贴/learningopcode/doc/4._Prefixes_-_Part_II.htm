<html>
<head>
<!-- Generated by the Spirit (http://spirit.sf.net) QuickDoc -->
<!-- 由罗聪(http://www.luocong.com)修改部分源代码，以适应中文的需求。 -->
<title>4. Prefixes - Part II</title>
<link rel="stylesheet" href="theme/style.css" type="text/css">
<link rel="prev" href="3._Prefixes_-_Part_I.htm">
<link rel="next" href="5._ModRM_-_Part_I.htm">
</head>
<body>
<table width="100%" height="48" border="0" background="theme/bkd2.gif" cellspacing="2">
  <tr>
    <td width="10">
    </td>
    <td width="85%">
      <font size="6" face="Verdana, Arial, Helvetica, sans-serif"><b>4. Prefixes - Part II</b></font>
    </td>
    <td width="112"><a href="http://spirit.sf.net"><img src="theme/spirit.gif" align="right" border="0"></a></td>
  </tr>
</table>
<br>
<table border="0">
  <tr>
    <td width="30"><a href="../index.htm"><img src="theme/u_arr.gif" title="目录" border="0"></a></td>
    <td width="30"><a href="3._Prefixes_-_Part_I.htm"><img src="theme/l_arr.gif" title="上一页" border="0"></a></td>
    <td width="20"><a href="5._ModRM_-_Part_I.htm"><img src="theme/r_arr.gif" title="下一页" border="0"></a></td>
   </tr>
</table>
<blockquote><p><i>I'll be back.<br><br></i>
-- Arnold Schwarzenegger, The Movie - &quot;Terminator&quot;(1984)</p></blockquote><a name="Prefixes合集"></a><h2>Prefixes合集</h2><p>
在前一章中我们已经知道：</p>
<ol><li>所有Prefixes的长度都是1个字节。</li><li>一个OpCode可能会有几个Prefixes。</li><li>如果有多个Prefixes，那么它们的顺序可以打乱。</li><li>如果Prefixes不能对随它之后的OpCode起作用，那么它就会被忽略。</li></ol><p>
现在我们将要学习剩下的几个Prefixes，它们可以被划分为5个集合，分别是：</p>
<ol><li>Change DEFAULT operand size. (<b>66</b>)</li><li>Change DEFAULT address size. (<b>67</b>)</li><li>Repeat prefixes. (<b>F2, F3</b>)</li><li>Segment override prefixes(change DEFAULT segment). (<b>2E, 36, 3E, 26, 64, 65</b>)</li><li>LOCK prefix. (<b>F0</b>)</li></ol><a name="<u>Prefix_66</u>"></a><h3><u>Prefix 66</u></h3><p>
在前面我们已经学习过它了，而且也够详细的了，对吗？<img src="theme/icon_wink.gif"></img></p>
<a name="<u>Prefix_67</u>"></a><h3><u>Prefix 67</u></h3><p>
改变默认的<b>地址</b>大小。</p>
<p>
请注意：<tt>67</tt>与<tt>66</tt>的分别在于，<tt>66</tt>改变的是默认的<b>操作数</b>大小，而<tt>67</tt>则是<b>地址</b>的大小。两者有什么差异呢？</p>
<code><pre>
<b>8A 00</b>    MOV AL, [EAX]
</pre></code><p>
现在把它的OpCode改成以<tt>67</tt>开头的：</p>
<code><pre>
<b>67 8A 00</b>    MOV AL, [BX+SI]
</pre></code><p>
我们可以看到：</p>
<ol><li><b>地址</b>由原来的<b>32</b>位的[EAX]变成了<b>16</b>位的[BX+SI]。</li><li>疑问来了：为什么不是[AX]，而是[BX+SI]呢？</li></ol><p>
第2个问题我们将会在以后的{<tt>ModR/M</tt>}和{<tt>SIB</tt>}的格式讲解中回答。现在我们可以暂时认为，在<b>16</b>位的地址模式中无法完全使用<b>32</b>位中的对应的地址模式，两种模式中的寄存器有着一定的区别。（看不明白？没关系，后面的章节中会详细解释）</p>
<p>
强调一点：Prefix 67同样也是一个“触发器”，它起的作用是“<b>切换</b>”，而不是“<b>指定</b>”。</p>
<a name="<u>Repeat_Prefixes_(F2,_F3)</u>"></a><h3><u>Repeat Prefixes (F2, F3)</u></h3><p>
Repeat Prefixes通常是与<tt>movs</tt>、<tt>scas</tt>、<tt>cmps</tt>等串指令搭配使用的，它们有：</p>
<code><pre>
<b><tt>F2</tt></b>: REPNE
<b><tt>F3</tt></b>: REP / REPE
</pre></code><p>
Repeat Prefixes作为一个串操作指令的前缀，它重复执行其后的串操作指令。每一次重复都先判断(E)CX是否为0，如为0就结束重复，否则(E)CX的值减1，然后再重复其后的串操作指令。所以当(E)CX的值为0时，就不再执行其后的操作指令。</p>
<p>
它类似于LOOP指令，但LOOP指令是先把(E)CX的值减1，后再判断是否为0。</p>
<p>
举例：</p>
<code><pre>
CLD
MOV ECX, 3
REP MOVSB
</pre></code><p>
运行的结果是把DS:(E)SI的3个字节(byte)移动到ES:(E)DI去。</p>
<p>
有两点规则：</p>
<ol><li>你可以看到有3种Repeat Prefixes的助记符：<tt>rep</tt>/<tt>repe</tt>/<tt>repene</tt>，但是只有2个OpCode：<tt>F2</tt>、<tt>F3</tt>。</li><li>如果某些指令<b><u>只使用</u></b>前缀<tt>rep</tt>，那么这里的<tt>rep</tt>可以用<tt>repe</tt>或者<tt>repne</tt>来代替。</li></ol><p>
第2条规则比较难以理解，对吗？我们来举个例子：</p>
<code><pre>
REP LODSB
REPE LODSB
REPNE LODSB
</pre></code><p>
这3条助记符的运行结果都是一样的：它会重复运行指令LODSB一共(E)CX次，而不管它的Repeat Prefixes是<tt>rep</tt>/<tt>repe</tt>[<tt>F3</tt>]还是<tt>repne</tt>[<tt>F2</tt>]。</p>
<p>
但是请注意：第2条规则的适用范围仅仅是<b><u>只使用</u></b>“<tt>rep</tt>”的指令，意即无论是<tt>F2</tt>还是<tt>F3</tt>，对指令的执行结果都无影响，而这样的指令非常的少！</p>
<p>
从OpCode的角度来看rep/repe[<tt>F3</tt>]和repne[<tt>F2</tt>]的区别：</p>
<p>
我们知道，重复串指令时可能会改变某些标志位（例如<tt>ZF</tt>），在这种情况下，有些指令与重复前缀搭配使用时，<tt>F2</tt>和<tt>F3</tt>会把<u>最后一位</u>与标志位<tt>ZF</tt>进行比较，如果它们不相同，则重复串指令的操作将会结束。而有些指令不用进行这个比较的操作，因此标志位<tt>ZF</tt>对这些指令的运行结果无影响。</p>
<p>
讲得不够清楚？呵呵，把<tt>F2</tt>和<tt>F3</tt>转换成二进制就能明白了。<img src="theme/icon_wink.gif"></img></p>
<code><pre>
1111 001<b>0</b>  <tt>F2</tt>
1111 001<b>1</b>  <tt>F3</tt>
</pre></code><p>
最后我们再来看看Repeat Prefixes的结束条件：</p>
<table width="90%" border="0" align="center">  <tr>
  <td class="table_title" colspan="12">
Repeat Prefiex的结束条件  </td>
  </tr>
<tr><td class="table_cells"><b>Repeat Prefix</b></td><td class="table_cells"><b>结束条件1</b></td><td class="table_cells"><b>结束条件2</b></td></tr><td class="table_cells">REP</td><td class="table_cells">ECX=0</td><td class="table_cells">None</td></tr><td class="table_cells">REPE</td><td class="table_cells">ECX=0</td><td class="table_cells">ZF=0</td></tr><td class="table_cells">REPNE</td><td class="table_cells">ECX=0</td><td class="table_cells">ZF=1</td></tr></table>
<p>
从上表中可以看出：<tt>repe</tt>和<tt>repne</tt>的结束必须同时满足两个结束条件，而<tt>rep</tt>只管ECX等不等于0。</p>
<p>
看到这里，再结合上面的第2条规则，我们就能更清楚了：由于<tt>rep</tt>并不与标志位<tt>ZF</tt>进行比较，所以它可以被替换成<tt>repe</tt>或者<tt>repne</tt>，对执行结果无影响！</p>
<a name="<u>Segment_Override_Prefixes_(2E,_36,_3E,_26,_64,_65)</u>"></a><h3><u>Segment Override Prefixes (2E, 36, 3E, 26, 64, 65)</u></h3><p>
我们先来看看这些Prefixes是什么：</p>
<table width="90%" border="0" align="center">  <tr>
  <td class="table_title" colspan="14">
Prefixes &amp;&amp; Explanation  </td>
  </tr>
<tr><td class="table_cells"><b>Prefix</b></td><td class="table_cells"><b>Explanation</b></td></tr><td class="table_cells">2E</td><td class="table_cells"><b>CS</b> segment override prefix</td></tr><td class="table_cells">36</td><td class="table_cells"><b>SS</b> segment override prefix</td></tr><td class="table_cells">3E</td><td class="table_cells"><b>DS</b> segment override prefix</td></tr><td class="table_cells">26</td><td class="table_cells"><b>ES</b> segment override prefix</td></tr><td class="table_cells">64</td><td class="table_cells"><b>FS</b> segment override prefix</td></tr><td class="table_cells">65</td><td class="table_cells"><b>GS</b> segment override prefix</td></tr></table>
<p>
再来看一个例子：</p>
<code><pre>
   <b>8B 03</b>    MOV EAX, [DWORD <tt>DS</tt>:EBX]
<b>65 8B 03</b>    MOV EAX, [DWORD <tt>GS</tt>:EBX]
</pre></code><p>
<tt>65</tt>就是一个Segment override prefix，用来改变<b>默认</b>的段，从上表中我们可以看出：<tt>65</tt>代表的是段<tt>GS</tt>。注意！这里也是用<b>默认</b>的概念。</p>
<p>
读者在这里也许会存在一个疑问：<b>默认</b>？我怎么知道当前默认的是哪个段呢？以及为什么要用<b>默认</b>的概念呢？</p>
<p>
答案是这样的：在使用内存中的数据时，处理器必须首先知道它的段地址(<tt>Segment</tt>)和偏移量(<tt>Offset</tt>)，但是如果在每个地方都要显式地直接指出段地址，那么在OpCode格式中就必须增加一个新的域，这将会比现有的OpCode体系多占用大量的字节，而且处理器也必须多花费额外的时钟周期来进行解码――无论在空间还是时间上，都不值得！</p>
<p>
因此，为了解决这个问题，一个方案诞生了：</p>
<p>
指令由不同的定义被划分为不同的组，每个组各自有一个<b>默认</b>的段：</p>
<code><pre>
<tt>CS</tt>: for <tt>EIP</tt> pointer
<tt>ES</tt>: 目的操作数是内存单元的串指令（movs, cmps等），在这里源操作数是储存在段DS里面。
<tt>SS</tt>: 堆栈操作（push, pop等）
<tt>DS</tt>: 剩下的数据操作指令。
</pre></code><p>
有了这个规则，处理器识别当前应该用哪个段将会变得非常简单而直接：</p>
<ol><li>如果有“Segment override prefix”，那么就使用这个prefix所指定的段。</li><li>否则就使用<b>默认</b>的段。</li></ol><p>
看看：</p>
<code><pre>
   <b>AC</b>     LODS [BYTE <tt>DS</tt>:ESI]
<b>3E AC</b>     LODS [BYTE <tt>DS</tt>:ESI]
</pre></code><p>
从上面的表中可以查出，<tt>3E</tt>是表示段<tt>DS</tt>，但是实际上在这里即使不直接指明<tt>3E</tt>，处理器也是会使用<tt>DS</tt>的，因为<tt>DS</tt>是指令<tt>LODS</tt>的默认段。</p>
<p>
最后值得一提的是<tt>64</tt>，它表示的是段<tt>FS</tt>，也许读者会对<tt>FS</tt>不太熟悉，平时好像很少会用到。没关系，我们来简单介绍一下：<tt>FS</tt>一般是由SEH（结构化异常处理）所使用，但是由于SEH不属于OpCode格式的范畴，所以我们在这里不必深究，知道有这个概念就行了。</p>
<a name="<u>LOCK_Prefix_(F0)</u>"></a><h3><u>LOCK Prefix (F0)</u></h3><p>
对于这个Prefix，Intel的文档已经解释得很清楚了，不过它的具体意义对OpCode的格式学习并无任何帮助，有兴趣的读者可以在&lt;&lt;Intel Architecture Software Developer's Manual Volume 2: Instruction Set Reference&gt;&gt;的3-387页看到关于它的详细解释。在OpCode的格式学习中，我们只需要知道<tt>F0</tt>表示的是助记符<tt>LOCK</tt>就足够了。</p>
<a name="The_End_Of_Prefixes"></a><h2>The End Of Prefixes</h2><p>
结束了吗？</p>
<p>
是的！关于Prefixes的格式学习到此就告一段落了。在接下来的章节中，我们将会学习最激动人心的一部分：如何对OpCode进行手工解码。</p>
<table border="0">
  <tr>
    <td width="30"><a href="../index.htm"><img src="theme/u_arr.gif" title="目录" border="0"></a></td>
    <td width="30"><a href="3._Prefixes_-_Part_I.htm"><img src="theme/l_arr.gif" title="上一页" border="0"></a></td>
    <td width="20"><a href="5._ModRM_-_Part_I.htm"><img src="theme/r_arr.gif" title="下一页" border="0"></a></td>
   </tr>
</table>
<br>
<hr size="1"><table align="center" bordor="0"><tr><td class="copyright">罗聪<br><font size="2"><a href="http://www.luocong.com" target="_blank">www.LuoCong.com</a></font><br><br></td></tr>
<tr><td><font size="2">（注：如果出现链接打不开的情况，请去掉IE浏览器的“<tt><font size="2">工具-&gt;Internet选项-&gt;高级-&gt;总是以UTF-8发送URL</font></tt>”前面的勾。谢谢！）</font></td></tr></table>
</body>
</html>
