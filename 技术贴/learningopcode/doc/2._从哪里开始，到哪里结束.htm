<html>
<head>
<!-- Generated by the Spirit (http://spirit.sf.net) QuickDoc -->
<!-- 由罗聪(http://www.luocong.com)修改部分源代码，以适应中文的需求。 -->
<title>2. 从哪里开始，到哪里结束</title>
<link rel="stylesheet" href="theme/style.css" type="text/css">
<link rel="prev" href="1._什么是OpCode？.htm">
<link rel="next" href="3._Prefixes_-_Part_I.htm">
</head>
<body>
<table width="100%" height="48" border="0" background="theme/bkd2.gif" cellspacing="2">
  <tr>
    <td width="10">
    </td>
    <td width="85%">
      <font size="6" face="Verdana, Arial, Helvetica, sans-serif"><b>2. 从哪里开始，到哪里结束</b></font>
    </td>
    <td width="112"><a href="http://spirit.sf.net"><img src="theme/spirit.gif" align="right" border="0"></a></td>
  </tr>
</table>
<br>
<table border="0">
  <tr>
    <td width="30"><a href="../index.htm"><img src="theme/u_arr.gif" title="目录" border="0"></a></td>
    <td width="30"><a href="1._什么是OpCode？.htm"><img src="theme/l_arr.gif" title="上一页" border="0"></a></td>
    <td width="20"><a href="3._Prefixes_-_Part_I.htm"><img src="theme/r_arr.gif" title="下一页" border="0"></a></td>
   </tr>
</table>
<blockquote><p><i>Everything that has a beginning... Has an end.<br><br></i>
-- Neo, The Movie - &quot;The Matrix: Revolutions&quot;(2003)</p></blockquote><a name="开始"></a><h2>开始</h2><p>
“从哪里开始，到哪里结束”，这是几乎所有的OpCode初学者都会问到的问题，具体来说，就是给定一串OpCode，计算机是如何知道哪里是某一条指令的开始，到哪里才是它的结束呢？</p>
<p>
让我们照例从实例开始说明：</p>
<code><pre>
<b>EB</b>:<tt>imm8</tt>
</pre></code><p>
这是一条近跳转指令，翻译成mnemonic就是<tt>jmp</tt>，<tt>imm8</tt>表示一个8位的立即数，整条指令的意思是<tt>jmp</tt>到<tt>imm8</tt>的偏移后的地址去。</p>
<p>
从上一章的内容中我们可以知道，这条OpCode的域格式是这样的：</p>
<code><pre>
{<tt>code</tt>}{<tt>Immediate</tt>}
</pre></code><p>
一共是2个字节。</p>
<p>
问题来了，我们用肉眼一看就知道，这代表2个字节，我们也知道这条指令应该是从<tt>EB</tt>开始，总长度是2个字节，到<tt>imm8</tt>为结束，可是计算机是怎么知道这一点的呢？假如有一串OpCode发送给处理器，例如“<tt>90EB0090</tt>”，让它从中找到这个<tt>jmp</tt>指令，它会不会认不出来呢？</p>
<p>
又或者，传送一串OpCode给处理器，例如“<tt>EB1234</tt>”，它会不会把后面的<tt>34</tt>也算进了<tt>jmp</tt>的跳转范围呢？</p>
<p>
答案是，不会的。</p>
<p>
CPU有个寄存器叫做<tt>EIP</tt>，它储存了内存中的某个地址，这个地址会告诉CPU，哪里是当前指令的开始；但是，在CPU没有对OpCode进行解码之前，它并不会知道哪里才是指令的结束。</p>
<p>
让我们来举个例子：</p>
<code><pre>
00401000    <b>90</b>    NOP
</pre></code><p>
第一列表示的是内存中的地址，在这里是<tt>00401000</tt>，它同时也是<tt>EIP</tt>的值，此时<tt>EIP</tt> = <tt>00401000</tt><br>
第二列表示的是OpCode，第三列表示的是mnemonic，相信不必多说，读者也能明白它们的意思：<tt>90</tt>对应<tt>NOP</tt></p>
<p>
由于<tt>EIP</tt> = <tt>00401000</tt>，所以CPU会知道当前的指令应该是从内存单元中的<tt>00401000</tt>开始，在这里，储存了一个OpCode：<tt>90</tt>，接下来CPU会对<tt>90</tt>进行解码：</p>
<code><pre>
OpCode：<tt>90</tt>
域格式：{<tt>code</tt>}
</pre></code><p>
只有1个字节。所以CPU就会知道，OpCode“<tt>90</tt>”是从内存地址“<tt>00401000</tt>”开始，到“<tt>00401001</tt>”结束。</p>
<p>
明白了吗？不过还有一种特殊情况：如果CPU遇到了无效的指令，它就会无法解析，例如OpCode“<tt>FFFF</tt>”，在运行的时候，会产生一个异常。</p>
<p>
再来看本章开头的：</p>
<code><pre>
<b>EB</b>:<tt>imm8</tt>
</pre></code><p>
<tt>EB</tt>是域{<tt>code</tt>}，当<tt>EIP</tt>遇到内存中的<tt>EB</tt>的地址时，CPU就会知道第1个字节后面会跟着一个<tt>imm8</tt>立即数，总长度是2个字节。</p>
<p>
至此，我们可以给出：</p>
<table width="80%" border="0" align="center">
  <tr>
    <td class="note_box">
<img src="theme/note.gif"></img> <b>初步的结论</b><br><br>
1. <u>开始</u>：处理器认为当前<tt>EIP</tt>指向的内存单元中的第一个字节就是指令的开始。<br>
2. <u>结束</u>：处理器通过对OpCode进行解码（大多数情况下是根据{<tt>code</tt>}域），从而知道哪里是结束。
    </td>
  </tr>
</table>
<p>
不过，不得不提的一点是：</p>
<ul><li><b>在运行完一条指令后，<tt>EIP</tt>并不总是指向下一条指令的开始！</b></li></ul><p>
举个例子：</p>
<code><pre>
00401000    <b>EB 00</b>    JMP 00000002
00401002    <b>90</b>       NOP
</pre></code><p>
此时<tt>EIP</tt> = <tt>00401000</tt>，<tt>EB00</tt>翻译成mnemonic就是<tt>JMP 00000002</tt>。为什么呢？因为<tt>EB:imm8</tt>是2个字节的OpCode，在这里<tt>imm8</tt>的值是<tt>00</tt>，所以<tt>00（imm8） + 02（本条OpCode的长度） = 02（应该跳转的地址）</tt>，也就是跳转到相对偏移为<tt>02</tt>的地方去。</p>
<p>
因此，<tt>EB00</tt>运行完后，<tt>EIP</tt>的值应该是<tt>00401002</tt>，也就是指向<tt>90</tt>的地址，下一步处理器将会执行指令“<tt>NOP</tt>”。</p>
<p>
好，再看：</p>
<code><pre>
00401000    <b>EB FE</b>    JMP 00000000
00401002    <b>90</b>       NOP
</pre></code><p>
此时<tt>EIP</tt> = <tt>00401000</tt>，但是为什么<tt>EBFE</tt>会是<tt>JMP 00000000</tt>呢？想想看？</p>
<p>
答案：<br>
FE + 02 = 100</p>
<p>
由于<tt>imm8</tt>的关系（8位只表示一个字节），<tt>100</tt>其实只取<tt>00</tt>（<tt>100</tt>其实是2个字节了――其高位为0，即<tt>0100</tt>）<br>
所以这条指令运行后，<tt>EIP</tt>应该还是<tt>00401000</tt>，没有改变！原因是这条指令的跳转地址是它本身！后面<tt>00401002</tt>处的“<tt>90</tt>”永远都不会执行！</p>
<p>
真正的底层程序员应该会理解指令的本质，而不仅仅是从指令的字面上去理解它的意思。例如，<tt>cmp</tt>，从字面上来看，表示<tt>compare</tt>一些东西。但是真正的底层程序员不会这样说，他会说，<tt>cmp</tt>表示的是用第一个操作数<u>减去</u>第二个操作数，由此来设置相应的标志位。同时，我们关心的只是标志位，并不关心减操作后的结果，所以不需要把减操作的结果储存到第一个操作数中。</p>
<p>
让我们回到正题。再来看一些应用：</p>
<p>
OpCode：<tt>04 AC</tt></p>
<code><pre>
00401000    <b>04 AC</b>    ADD AL, 0AC
</pre></code><p>
我们已经知道，<tt>AC</tt>是助记符<tt>lodsb</tt>的OpCode，<tt>00401000</tt>是OpCode <tt>04AC</tt>的开始地址，而<tt>00401002</tt>将会是它的结束（这个指令只有2个字节的关系）。但是，我们一直以来都没讨论的是：如果把这条OpCode从中间截断！即从<tt>00401001</tt>地址处开始的指令会是什么呢？</p>
<p>
如果我们把寄存器<tt>EIP</tt>的内容设置成<tt>00401001</tt>，我们就会发现：<br>
处理器会把<tt>AC</tt>看作<tt>lodsb</tt>，而不是：<br>
ADD AL, 0AC<br>
<b>04</b>:<tt>imm8</tt>(AL+imm8)中的<tt>imm8</tt></p>
<p>
应用这个原理，我们来看一个小例子，假设要实现下面的算法：</p>
<code><pre>
IF zf = 0
	lodsb
ELSE
	add al, 0AC
</pre></code><p>
试试写成助记符？不知道读者朋友们会怎么写――我会写成这样：</p>
<code><pre>
jnz $+1
add al, 0AC
</pre></code><p>
解释如下：</p>
<code><pre>
如果标志位<b>zf</b>等于0，则<tt>EIP</tt>会指向<tt>add al, 0AC</tt>的第2个字节，也就是<tt>AC</tt>――我们知道<tt>AC</tt>表示助记符<tt>lodsb</tt>
明白了吗？使人惊奇的是，整个算法的实现只用了区区4个字节！
</pre></code><p>
这个算法的OpCode:</p>
<code><pre>
00401000    <b>75 01</b>    JNZ SHORT 3
00401002    <b>04 AC</b>    ADD AL, 0AC
</pre></code><p>
让我们来看看每个字节表示什么意思：</p>
<p>
<b>75</b>:<tt>imm8</tt> 是 <tt>7501</tt> 的域格式<br>
<b>75</b>是<tt>JNZ</tt>的OpCode，<tt>imm8</tt>在这里是<tt>01</tt>，会加到<tt>EIP</tt>里面去，整个<tt>7501</tt>表示如果这条指令被执行了，则<tt>EIP</tt>会指向下一条指令的第2个字节的地址。</p>
<p>
<tt>04AC</tt>的域格式：<br>
<b>04</b>:<tt>imm8</tt> 其中：<br>
<b>04</b> - {<tt>code</tt>}<br>
<b>AC</b> - {<tt>Immediate</tt>}</p>
<p>
整个算法实现的思路如下：</p>
<p>
如果<u>zf=0</u>，<tt>7501</tt>这条指令就会把下一条指令的起始地址+1（<tt>75</tt>后面的操作数就是需要跳的字节数：0不跳，1跳一个，n就跳n个……但是字节是有符号的，负的就往后跳……所以<tt>jnz short xxx</tt>是有最大的跳跃限制的），然后把跳跃后的地址赋值给<tt>EIP</tt>――也就是<tt>00401003</tt>，从而迫使处理器认为<tt>AC</tt>所在的地址才是下一条指令的开始（跳过了OpCode <tt>04</tt>），这时，<tt>AC</tt>会被当成{<tt>code</tt>}。</p>
<p>
否则，<tt>EIP</tt>会指向<tt>04AC</tt>所在的地址<tt>00401002</tt>，所以下一条指令的开始就会从<tt>04</tt>开始算起，处理器会认出域格式：<br>
<b>04</b>:<tt>imm8</tt>(add al, imm8)<br>
这时，<tt>AC</tt>会被当成{<tt>Immediate</tt>}，而不是{<tt>code</tt>}。</p>
<p>
呵呵，是不是有点儿迷糊了？<img src="theme/icon_wink.gif"></img></p>
<p>
为了加深理解，最后再给大家看一个算法及其实现：</p>
<code><pre>
IF zf = 0
	inc eax
ELSE
	mov al, 40
</pre></code><p>
答案：</p>
<code><pre>
00401000    <b>75 01</b>    JNZ SHORT 3
00401002    <b>B0 40</b>    MOV AL, 40
</pre></code><p>
嗯……提示一下：<tt>40</tt>表示的是<tt>inc eax</tt>……聪明的你，明白了吗？</p>
<a name="结束"></a><h2>结束</h2><p>
本章到这里已经结束了，但是……OpCode的学习只是刚刚开始而已，请大家打好精神，为后面的旅程作好准备！<img src="theme/icon_wink.gif"></img></p>
<table border="0">
  <tr>
    <td width="30"><a href="../index.htm"><img src="theme/u_arr.gif" title="目录" border="0"></a></td>
    <td width="30"><a href="1._什么是OpCode？.htm"><img src="theme/l_arr.gif" title="上一页" border="0"></a></td>
    <td width="20"><a href="3._Prefixes_-_Part_I.htm"><img src="theme/r_arr.gif" title="下一页" border="0"></a></td>
   </tr>
</table>
<br>
<hr size="1"><table align="center" bordor="0"><tr><td class="copyright">罗聪<br><font size="2"><a href="http://www.luocong.com" target="_blank">www.LuoCong.com</a></font><br><br></td></tr>
<tr><td><font size="2">（注：如果出现链接打不开的情况，请去掉IE浏览器的“<tt><font size="2">工具-&gt;Internet选项-&gt;高级-&gt;总是以UTF-8发送URL</font></tt>”前面的勾。谢谢！）</font></td></tr></table>
</body>
</html>
