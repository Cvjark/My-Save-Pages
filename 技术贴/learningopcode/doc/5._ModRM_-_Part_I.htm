<html>
<head>
<!-- Generated by the Spirit (http://spirit.sf.net) QuickDoc -->
<!-- 由罗聪(http://www.luocong.com)修改部分源代码，以适应中文的需求。 -->
<title>5. ModRM - Part I</title>
<link rel="stylesheet" href="theme/style.css" type="text/css">
<link rel="prev" href="4._Prefixes_-_Part_II.htm">
</head>
<body>
<table width="100%" height="48" border="0" background="theme/bkd2.gif" cellspacing="2">
  <tr>
    <td width="10">
    </td>
    <td width="85%">
      <font size="6" face="Verdana, Arial, Helvetica, sans-serif"><b>5. ModRM - Part I</b></font>
    </td>
    <td width="112"><a href="http://spirit.sf.net"><img src="theme/spirit.gif" align="right" border="0"></a></td>
  </tr>
</table>
<br>
<table border="0">
  <tr>
    <td width="30"><a href="../index.htm"><img src="theme/u_arr.gif" title="目录" border="0"></a></td>
    <td width="30"><a href="4._Prefixes_-_Part_II.htm"><img src="theme/l_arr.gif" title="上一页" border="0"></a></td>
    <td width="20"><img src="theme/r_arr_disabled.gif" border="0"></td>
   </tr>
</table>
<blockquote><p><i>道，可道，非常道。<br><br></i>
-- 老子，《道德经》</p></blockquote><a name="基本概念"></a><h2>基本概念</h2><p>
让我们从最经常用到的域开始学起――<tt>ModR/M</tt>。</p>
<p>
在开始之前，先来讲一些最基础的概念，扫扫盲。<img src="theme/icon_wink.gif"></img></p>
<p>
一个字节如果被转换成二进制，则是由8位（bit）来表示（不足8位的话则高位用0来补足），例如：</p>
<code><pre>
16进制      2进制
B7          1011 0111
3A          0011 1010
</pre></code><p>
示例中的B7的二进制是1011 0111，这是典型的4:4表示格式――1011表示的是B，0111表示的是7，这样，1011 0111表示的就是B7了。</p>
<p>
很容易理解吧？呵呵，那么我们可不可以用另外一种方式来表示一个字节呢？</p>
<p>
答案是肯定的：</p>
<code><pre>
16进制      2进制的<b>4:4</b>格式      2进制的<b>2:3:3</b>格式
B7          1011 0111           10 110 111
3A          0011 1010           00 111 010
</pre></code><p>
请看，我们在这里引进了一种新的表示格式：<b>2:3:3</b></p>
<p>
它的特点是把一个字节的8位二进制分成3个部分：最高的2位表示的是一个东西，接下来的3位表示的是另外一个东西，以及最后的3位表示的是另另外一个东西。</p>
<p>
好了，明白了这一点后，我们来开始吧！</p>
<p>
首先回忆一下OpCode的组成格式：</p>
<ol><li>Prefixes</li><li>code</li><li><b>ModR/M</b></li><li>SIB</li><li>Displacement</li><li>Immediate</li></ol><p>
请注意第三项：<b>ModR/M</b>，它占一个字节，其格式为：</p>
<code><pre>
7 6  5        3  2 0
Mod  Reg/Opcode  R/M
</pre></code><p>
可见，<b>ModR/M</b>是由<tt>Mod</tt>、<tt>Reg/Opcode</tt>和<tt>R/M</tt>三个部分组成的。每个部分所占的bit大小为：</p>
<code><pre>
       <tt>Mod</tt>: 占最高位的6～7共2个bit
<tt>Reg/Opcode</tt>: 占中间位的3～5共3个bit
       <tt>R/M</tt>: 占最低位的0～2共3个bit
</pre></code><p>
呵呵，正好是<b>2:3:3</b>的格式！<img src="theme/icon_smile.gif"></img></p>
<p>
<b>ModR/M</b>的具体描述如下面两个表，第一个是16位的，第二个是32位的：<br>
（截图自《IA-32 Intel Architecture Software Developer's Manual Volume 2: Instruction Set Reference》，页码2-5，2-6，希望Intel不要因为版权问题找我的麻烦）</p>
<p>
<b>- 16位 -</b><br>
<img src="images/16bitmodrm.gif"></img><br></p>
<p>
<b>- 32位 -</b><br>
<img src="images/32bitmodrm.gif"></img><br></p>
<p>
哇，这两个图好复杂呀！你是不是已经有了这个感慨了呢？</p>
<p>
呵呵不要紧，让我们来举个例子看看<b>ModR/M</b>到底是怎么来看的：</p>
<code><pre>
mov edi, ecx	8B <b>F9</b>
sub edi, ecx	2B <b>F9</b>
</pre></code><p>
注意这两个OpCode的第二个字节――都是<b>F9</b>，再来看看OpCode的格式：</p>
<code><pre>
Prefixes  Code  <b>ModR/M</b>  SIB  Displacement  Immediate
</pre></code><p>
我们在前面说过，在OpCode的格式中，只有<tt>Code</tt>是必须有的，别的都是可选的。所以，在8B F9和2B F9这两组OpCode中，8B和2B就是<tt>Code</tt>，（这里没有Prefixes，因为Prefixes只有在前面的章节中所介绍过的那几个：66、67、F2、F3、2E、36、3E、26、64、65、F0）。</p>
<p>
紧接着在<tt>Code</tt>后面的就是<tt>ModR/M</tt>了，所以在这两组OpCode中的<b>F9</b>就是<tt>ModR/M</tt>。（在这里也没有<tt>SIB</tt>、<tt>Displacement</tt>和<tt>Immediate</tt>）</p>
<p>
<b>F9</b>的4:4格式的二进制是<b>1111 1001</b>，我们把它分解成2:3:3的二进制看看：</p>
<code><pre>
16进制      2进制的2:3:3格式
F9          11 111 001
</pre></code><p>
也就是：</p>
<code><pre>
       <tt>Mod</tt>: 11
<tt>Reg/Opcode</tt>: 111
       <tt>R/M</tt>: 001
</pre></code><p>
晕头转向了？呵呵，让我们来对其分而治之吧！</p>
<p>
假设是在32位模式下。从上面的第二个图中可以看到，<tt>Mod</tt>总共分为00、01、10、11四种情况，每种情况又分别有8种情况。现在<tt>Mod</tt>是11，所以我们应该看<tt>Mod</tt>为11的那一栏。</p>
<p>
OK，现在来讨论第二个：<tt>Reg/Opcode</tt></p>
<p>
<tt>Reg/Opcode</tt>中间的那个“/”表示“或”，意思就是，这个地方可以表示为<tt>Reg</tt>或者<tt>Opcode</tt>――至于到底什么时候表示<tt>Reg</tt>，什么时候表示<tt>Opcode</tt>，这就要由<tt>Code</tt>来决定了。目前我们不必去深究它，后面会讲明白的，我们只要知道，如果它是表示<tt>Opcode</tt>，则这个指令必定是2个字节的。</p>
<p>
<tt>Reg</tt>由3个bit的二进制组成，因此，它可以表示：</p>
<code><pre>
2 ^ 3 = 8
</pre></code><p>
一共8种可能的值。我们知道，常用的通用寄存器恰好也有8个，因此，根据组合数学的常识，可以得到：</p>
<table width="90%" border="0" align="center">  <tr>
  <td class="table_title" colspan="18">
REG &amp;&amp; Register  </td>
  </tr>
<tr><td class="table_cells"><b>REG</b></td><td class="table_cells"><b>Register</b></td></tr><td class="table_cells">000</td><td class="table_cells">EAX</td></tr><td class="table_cells">001</td><td class="table_cells">ECX</td></tr><td class="table_cells">010</td><td class="table_cells">EDX</td></tr><td class="table_cells">011</td><td class="table_cells">EBX</td></tr><td class="table_cells">100</td><td class="table_cells">ESP</td></tr><td class="table_cells">101</td><td class="table_cells">EBP</td></tr><td class="table_cells">110</td><td class="table_cells">ESI</td></tr><td class="table_cells">111</td><td class="table_cells">EDI</td></tr></table>
<p>
这是在32位的模式下得到的。</p>
<p>
在16位的模式下，<tt>Reg</tt>则是表示另外一种“局部”的格式，它的低4位表示寄存器的低地址，高4位表示寄存器的高地址，如下表：</p>
<table width="90%" border="0" align="center">  <tr>
  <td class="table_title" colspan="18">
REG &amp;&amp; Register  </td>
  </tr>
<tr><td class="table_cells"><b>REG</b></td><td class="table_cells"><b>Register</b></td></tr><td class="table_cells">000</td><td class="table_cells">AL</td></tr><td class="table_cells">001</td><td class="table_cells">CL</td></tr><td class="table_cells">010</td><td class="table_cells">DL</td></tr><td class="table_cells">011</td><td class="table_cells">BL</td></tr><td class="table_cells">100</td><td class="table_cells">AH</td></tr><td class="table_cells">101</td><td class="table_cells">CH</td></tr><td class="table_cells">110</td><td class="table_cells">DH</td></tr><td class="table_cells">111</td><td class="table_cells">BH</td></tr></table>
<p>
好了，把目光返回到上面的32位<b>ModR/M</b>图，看看最上面，在<tt>r32(/r)</tt>那一栏中，<tt>REG=111</tt>表示的就是寄存器<tt>EDI</tt></p>
<p>
到目前为止，最后剩下还没讨论的就是<tt>R/M</tt>。这一栏要与<tt>Mod</tt>结合起来。我们来看<tt>Mod</tt>为11的那一栏――<tt>R/M</tt>为001对应的寄存器是ECX</p>
<p>
好了！大功告成！整理如下：</p>
<code><pre>
       <tt>Mod</tt>: 11  表示应该查看Mod为11的那一栏
<tt>Reg/Opcode</tt>: 111 表示的是寄存器EDI
       <tt>R/M</tt>: 001 表示的是ECX
</pre></code><p>
因此，通过OpCode：</p>
<code><pre>
8B <b>F9</b>
2B <b>F9</b>
</pre></code><p>
不难得到：</p>
<code><pre>
mov edi, ecx	8B <b>F9</b>
sub edi, ecx	2B <b>F9</b>
</pre></code><p>
（注：8B是助记符“MOV”的<tt>Code</tt>，2B是助记符“SUB”的<tt>Code</tt>）</p>
<table border="0">
  <tr>
    <td width="30"><a href="../index.htm"><img src="theme/u_arr.gif" title="目录" border="0"></a></td>
    <td width="30"><a href="4._Prefixes_-_Part_II.htm"><img src="theme/l_arr.gif" title="上一页" border="0"></a></td>
    <td width="20"><img src="theme/r_arr_disabled.gif" border="0"></td>
   </tr>
</table>
<br>
<hr size="1"><table align="center" bordor="0"><tr><td class="copyright">罗聪<br><font size="2"><a href="http://www.luocong.com" target="_blank">www.LuoCong.com</a></font><br><br></td></tr>
<tr><td><font size="2">（注：如果出现链接打不开的情况，请去掉IE浏览器的“<tt><font size="2">工具-&gt;Internet选项-&gt;高级-&gt;总是以UTF-8发送URL</font></tt>”前面的勾。谢谢！）</font></td></tr></table>
</body>
</html>
