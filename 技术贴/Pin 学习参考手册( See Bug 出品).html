<!DOCTYPE html>
<!-- saved from url=(0030)https://paper.seebug.org/1742/ -->
<html xmlns:wb="http://open.weibo.com/wb"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta property="wb:webmaster" content="ccd3e79934f3322d">
  <title>Pin 学习参考手册</title>
  <meta name="keywords" content="漏洞文档,漏洞分析,安全技术">
  <meta name="description" content="">

  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link rel="shortcut icon" href="https://paper.seebug.org/static/images/favicon.ico">
  <link rel="stylesheet" type="text/css" href="./Pin 学习参考手册( See Bug 出品)_files/bootstrap.min.css">
  <link rel="stylesheet" type="text/css" href="./Pin 学习参考手册( See Bug 出品)_files/screen.css">
  <link rel="stylesheet" type="text/css" href="./Pin 学习参考手册( See Bug 出品)_files/font.css">
  <link rel="stylesheet" type="text/css" href="./Pin 学习参考手册( See Bug 出品)_files/plugin_comment.css">
  <link rel="stylesheet" href="./Pin 学习参考手册( See Bug 出品)_files/font-awesome.min.css">
  <link rel="stylesheet" type="text/css" href="./Pin 学习参考手册( See Bug 出品)_files/prism.css">
  <link rel="stylesheet" type="text/css" href="./Pin 学习参考手册( See Bug 出品)_files/monokai.css" media="screen">
  <link rel="stylesheet" type="text/css" href="./Pin 学习参考手册( See Bug 出品)_files/custom.css">
  <link rel="stylesheet" type="text/css" href="./Pin 学习参考手册( See Bug 出品)_files/print.css" media="print">
<script type="text/javascript" src="./Pin 学习参考手册( See Bug 出品)_files/jquery.min.js.下载"></script>
<style id="fit-vids-style">.fluid-width-video-wrapper{width:100%;position:relative;padding:0;}.fluid-width-video-wrapper iframe,.fluid-width-video-wrapper object,.fluid-width-video-wrapper embed {position:absolute;top:0;left:0;width:100%;height:100%;}</style></head>

<body class="home-template">
<div class="weixin-share-img" style="display: none">
  <img src="./Pin 学习参考手册( See Bug 出品)_files/weixin-share.png" alt="Paper">
</div>

<div id="wrapper" class="">

<div id="sidebar">
  <button type="button" class="hamburger is-closed" data-toggle="offcanvas">
    <span class="hamb-top"></span>
    <span class="hamb-middle"></span>
    <span class="hamb-bottom"></span>
  </button>
  <div id="sidebar-content" class="inner">
    <h2 class="blog-title">
        <img src="./Pin 学习参考手册( See Bug 出品)_files/seebug-logo2.png" alt="Seebug-logo">
    </h2>
    <h3 class="blog-description">Paper - 安全技术精粹</h3>

    <form id="search" action="https://paper.seebug.org/">
      <button type="submit" style="background: #13313f; border: #13313f; position: absolute; right: -4px; margin-top: -3px;">
        <i class="fa fa-search search-button" style="position: absolute;right:10px; margin-top:6px;"> </i>
      </button>
      <input id="search-field" name="keyword" value="" placeholder="Search">

    </form>
    <div class="overlay"></div>
    <div id="sidebar-links">
      <ul id="subscription-links">
        <li><a target="_blank" href="https://paper.seebug.org/rss/"><i class="fa fa-rss"></i>RSS 订阅</a>
        </li>
        <li><a href="https://paper.seebug.org/contribution/paper/"><i class="fa fa-envelope-o"></i>投稿</a></li>
          <li><a href="https://paper.seebug.org/rank/"><i class="glyphicon glyphicon-signal"></i>阅读榜</a></li>
      </ul>
      <ul id="navigation">
        <li class="nav-" role="presentation"><a href="https://paper.seebug.org/"><i class="fa fa-angle-right"></i>首页</a></li>
        
  <li class="nav-" role="presentation"><a href="https://paper.seebug.org/category/vul-analysis/"><i class="fa fa-angle-right"></i>漏洞分析</a></li>

  <li class="nav-" role="presentation"><a href="https://paper.seebug.org/category/tools/"><i class="fa fa-angle-right"></i>安全工具&amp;安全开发</a></li>

  <li class="nav-" role="presentation"><a href="https://paper.seebug.org/category/information/"><i class="fa fa-angle-right"></i>情报分析</a></li>

  <li class="nav-" role="presentation"><a href="https://paper.seebug.org/category/experience/"><i class="fa fa-angle-right"></i>经验心得</a></li>

  <li class="nav-" role="presentation"><a href="https://paper.seebug.org/category/web-security/"><i class="fa fa-angle-right"></i>Web安全</a></li>

  <li class="nav-" role="presentation"><a href="https://paper.seebug.org/category/bin-security/"><i class="fa fa-angle-right"></i>二进制安全</a></li>

  <li class="nav-" role="presentation"><a href="https://paper.seebug.org/category/mobile-security/"><i class="fa fa-angle-right"></i>移动安全</a></li>

  <li class="nav-" role="presentation"><a href="https://paper.seebug.org/category/prime/"><i class="fa fa-angle-right"></i>安全基础&amp;教学篇</a></li>

  <li class="nav-" role="presentation"><a href="https://paper.seebug.org/category/ctf/"><i class="fa fa-angle-right"></i>CTF</a></li>

  <li class="nav-" role="presentation"><a href="https://paper.seebug.org/category/IoT/"><i class="fa fa-angle-right"></i>IoT安全</a></li>

  <li class="nav-" role="presentation"><a href="https://paper.seebug.org/category/blockchain/"><i class="fa fa-angle-right"></i>区块链</a></li>

  <li class="nav-" role="presentation"><a href="https://paper.seebug.org/category/404team/"><i class="fa fa-angle-right"></i>404专栏</a></li>

  <li class="nav-" role="presentation"><a href="https://paper.seebug.org/category/report/"><i class="fa fa-angle-right"></i>专题报告</a></li>

  <li class="nav-" role="presentation"><a href="https://paper.seebug.org/category/404team-en/"><i class="fa fa-angle-right"></i>404 English Paper</a></li>

  <li class="nav-" role="presentation"><a href="https://paper.seebug.org/category/threat-intelligence/"><i class="fa fa-angle-right"></i>威胁情报</a></li>


        <li class="nav-" role="presentation"><a href="https://paper.seebug.org/call-for-paper/"><i class="fa fa-angle-right"></i>如何投稿</a></li>
        <li class="nav-" role="presentation"><a href="https://paper.seebug.org/papers/"><i class="fa fa-angle-right"></i>归档文件</a></li>
      </ul>
      <ul id="sidebar-external">
      </ul>
    </div>

    <footer class="site-footer">
      <section class="copyright">Copyright @ 404 Team from Knownsec.</section>
    </footer>
  </div>
</div>

<main>
  <div class="main-inner">
    <section id="results"></section>
    
<article class="">
    <header class="post-header">

        <h1 class="post-title" id="1953">Pin 学习参考手册</h1>

        <span class="post-print">
        <a href="javascript:window.print()">
        <i class="fa fa-print fa-2x" aria-hidden="true"></i>
        </a>
      </span>
        <section class="post-meta">
        <span class="post-time">
          <i class="fa fa-calendar"></i>
          <time datetime="2021-10-20" class="timeago">2021年10月20日</time>
          <time datetime="2021-10-20" class="fulldate">2021年10月20日</time>
        </span>
            
            <br>
            <i class="fa fa-tag"></i>
            
            <a href="https://paper.seebug.org/category/experience/">经验心得</a>
            
            
            

            <!--                -->
            <!--                -->
            <!--                -->
            <!--                -->
            <!--                -->
            <!--                -->

        </section>
    </header>
    <div class="x_panel" id="md-catalog">
        <div class="x_title">
            <h2>目录</h2>
            <ul class="nav navbar-right panel_toolbox">
                <li><a class="collapse-link">
                    <i class="fa fa-chevron-up"></i>
                </a></li>
                <li><a class="close-link">
                    <i class="fa fa-times"></i>
                </a></li>
            </ul>
            <div class="clearfix"></div>
        </div>
        <div class="toc">
<ul>
<li><a href="https://paper.seebug.org/1742/#1">1. 简介</a></li>
<li><a href="https://paper.seebug.org/1742/#2-pin">2. 使用Pin进行插桩</a><ul>
<li><a href="https://paper.seebug.org/1742/#1-pin">1. Pin</a></li>
<li><a href="https://paper.seebug.org/1742/#2-pintools">2. Pintools</a></li>
<li><a href="https://paper.seebug.org/1742/#3">3. 插桩粒度</a><ul>
<li><a href="https://paper.seebug.org/1742/#1-trace-instrumentation">1. trace instrumentation</a></li>
<li><a href="https://paper.seebug.org/1742/#2-instruction-instrumentation">2. instruction instrumentation</a></li>
<li><a href="https://paper.seebug.org/1742/#3-image-instrumentation">3. image instrumentation</a></li>
<li><a href="https://paper.seebug.org/1742/#4-routine-instrumentation">4. routine instrumentation</a></li>
</ul>
</li>
<li><a href="https://paper.seebug.org/1742/#4">4. 符号</a></li>
</ul>
</li>
<li><a href="https://paper.seebug.org/1742/#3_1">3. 官方样例</a><ul>
<li><a href="https://paper.seebug.org/1742/#1_1">1. 构建样例工具</a></li>
<li><a href="https://paper.seebug.org/1742/#2">2. 简单的指令计数（指令插桩）</a></li>
<li><a href="https://paper.seebug.org/1742/#3_2">3. 指令地址跟踪（指令插桩）</a></li>
<li><a href="https://paper.seebug.org/1742/#4_1">4. 内存调用跟踪（指令插桩）</a></li>
<li><a href="https://paper.seebug.org/1742/#5-imageimage">5. 检测image的加载和卸载（image插桩）</a></li>
<li><a href="https://paper.seebug.org/1742/#6-trace">6. 进阶版指令计数（trace 插桩）</a></li>
<li><a href="https://paper.seebug.org/1742/#7-procedure-routine">7. Procedure 指令计数（routine插桩）</a></li>
<li><a href="https://paper.seebug.org/1742/#8-pin_safecopy-api">8. PIN_SafeCopy() API</a></li>
<li><a href="https://paper.seebug.org/1742/#9">9. 插桩顺序</a></li>
<li><a href="https://paper.seebug.org/1742/#10">10. 查看函数参数值</a></li>
<li><a href="https://paper.seebug.org/1742/#11">11. 插桩线程应用</a></li>
<li><a href="https://paper.seebug.org/1742/#12-tlsthread-local-storage">12. 使用TLS(Thread Local Storage)</a></li>
<li><a href="https://paper.seebug.org/1742/#13-image">13. 查看image的静态属性</a></li>
<li><a href="https://paper.seebug.org/1742/#14">14. 插桩子进程</a></li>
<li><a href="https://paper.seebug.org/1742/#15-forkfork">15. 在fork前和fork后插桩</a></li>
</ul>
</li>
<li><a href="https://paper.seebug.org/1742/#4_2">4. 回调</a><ul>
<li><a href="https://paper.seebug.org/1742/#pinapi">PIN回调操作相关API</a></li>
<li><a href="https://paper.seebug.org/1742/#call_order">CALL_ORDER</a></li>
</ul>
</li>
<li><a href="https://paper.seebug.org/1742/#5">5. 修改程序指令</a><ul>
<li><a href="https://paper.seebug.org/1742/#51">5.1 实现方式</a><ul>
<li><a href="https://paper.seebug.org/1742/#ins_insertdirectjump">INS_InsertDirectJump()</a></li>
<li><a href="https://paper.seebug.org/1742/#ins_insertindirectjump">INS_InsertIndirectJump()</a></li>
</ul>
</li>
<li><a href="https://paper.seebug.org/1742/#52">5.2 指令内存修改</a><ul>
<li><a href="https://paper.seebug.org/1742/#ins_rewritememoryoperand">INS_RewriteMemoryOperand()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="https://paper.seebug.org/1742/#6-pintool">6. 应用Pintool</a><ul>
<li><a href="https://paper.seebug.org/1742/#61-pin">6.1 Pin命令行选项</a></li>
<li><a href="https://paper.seebug.org/1742/#62-intelr-64">6.2 在Intel(R) 64架构插桩</a></li>
<li><a href="https://paper.seebug.org/1742/#63">6.3 注入</a></li>
</ul>
</li>
<li><a href="https://paper.seebug.org/1742/#7-pintool">7. 编写Pintool</a><ul>
<li><a href="https://paper.seebug.org/1742/#71-pintool">7.1 记录Pintool的消息</a></li>
<li><a href="https://paper.seebug.org/1742/#72-pintool">7.2 编写Pintool时的性能考量</a></li>
<li><a href="https://paper.seebug.org/1742/#73">7.3 消除控制流</a></li>
<li><a href="https://paper.seebug.org/1742/#74-pin">7.4 让Pin决定插桩位置</a></li>
<li><a href="https://paper.seebug.org/1742/#75-fast-call-linkages">7.5 使用Fast Call Linkages</a></li>
<li><a href="https://paper.seebug.org/1742/#76-pin">7.6 重写有条件的分析例程实现Pin内联</a></li>
</ul>
</li>
<li><a href="https://paper.seebug.org/1742/#8-pintool">8. 构建自己的Pintool</a><ul>
<li><a href="https://paper.seebug.org/1742/#81">8.1 在套件目录树内进行构建</a></li>
<li><a href="https://paper.seebug.org/1742/#82">8.2 在套件目录树外构建</a></li>
</ul>
</li>
<li><a href="https://paper.seebug.org/1742/#9-pinmakefile">9. Pin的makefile</a><ul>
<li><a href="https://paper.seebug.org/1742/#91">9.1 配置目录</a></li>
<li><a href="https://paper.seebug.org/1742/#92">9.2 测试目录</a></li>
<li><a href="https://paper.seebug.org/1742/#93-makefile">9.3 向makefile中添加测试、工具和应用</a></li>
<li><a href="https://paper.seebug.org/1742/#94">9.4 定义构建规则</a></li>
<li><a href="https://paper.seebug.org/1742/#95-makefilerules">9.5 在makefile.rules定义测试片段</a></li>
<li><a href="https://paper.seebug.org/1742/#96">9.6 变量和标志</a></li>
</ul>
</li>
</ul>
</div>

    </div>
    <section class="post-content">
        <p><strong>作者： 深信服千里目安全实验室<br>
原文链接：<a href="https://mp.weixin.qq.com/s/K4icyU6tmZYMrvgNL_jYDw">https://mp.weixin.qq.com/s/K4icyU6tmZYMrvgNL_jYDw</a></strong></p>
<p>使用的Pin版本：3.20</p>
<h2 id="1"><strong><em>1. 简介</em></strong></h2>
<p>Pin 是一个动态二进制插桩工具，支持 Linux， macOS 和 Windows 操作系统以及可执行程序。Pin可以通过pintools在程序运行期间动态地向可执行文件的任意位置插入任意代码（C/C++），也可以attach到一个正在运行的进程。</p>
<p>Pin 提供了丰富的 API，可以抽象出底层指令集特性，并允许将进程的寄存器数据等的上下文信息作为参数传递给注入的代码。Pin会自动存储和重置被注入代码覆盖的寄存器，以恢复程序的继续运行。对符号和调试信息也可以设置访问权限。</p>
<p>Pin内置了大量的样例插桩工具的源码，包括基本块分析其、缓存模拟器、指令跟踪生成器等，根据自己的实际需求进行自定义开发也十分方便。</p>
<h2 id="2-pin"><strong><em>2. 使用Pin进行插桩</em></strong></h2>
<h3 id="1-pin"><strong><em>1. Pin</em></strong></h3>
<p>对 Pin 的一个最合适的理解是可以将 Pin 当作一个 JIT 编译器，只是它的输入不是字节码，而是可执行文件。Pin 会拦截可执行文件的第一条指令，然后对从该指令开始的后续的指令序列重新“compile”新的代码，然后控制权限转移到新生成的代码。生成的代码与原始代码几乎一致，但是 Pin 会保证在分支退出代码序列时重新获得控制权限。重新获得控制权后，Pin 会基于分支生成更多的代码，然后继续运行。Pin 将所有生成的代码都保存在内存中，这样可以实现代码重用。</p>
<p>在这种 JIT 模式下，执行的是生成的代码，原始代码仅作为参考。当生成代码时，Pin 会给到用户注入自己想执行的代码（插桩）的机会。</p>
<p>Pin 对所有实际执行的代码进行插桩，不管代码具体处于哪个 section 。虽然对于一些条件分支会存在异常，但是如果指令没有被执行过，就一定不会被插桩。</p>
<p>Pin的完整架构如下：</p>
<p><img alt="" src="./Pin 学习参考手册( See Bug 出品)_files/c3d2a49e-0432-4eb4-b3cc-998c66d9d4aa.png-w331s"> </p>
<p>Pin工作在操作系统之上，所以只能捕获用户级别的指令。在一个经过插桩的程序运行时，同时有3个程序运行：应用程序本身、Pin、Pintool。Pin是对应用程序进行插桩的引擎，Pintool中包含了插桩的指令，可以看作是Pin的一个library。三者共享同一个地址空间，但不共享库，避免了冲突。</p>
<h3 id="2-pintools"><strong><em>2. Pintools</em></strong></h3>
<p>在概念上，插桩主要包含两部分内容：</p>
<ul>
<li>插桩机制（instrumentation code）</li>
</ul>
<p>在什么位置插入什么样的代码</p>
<ul>
<li>分析代码（analysis code）</li>
</ul>
<p>在插桩点执行的代码</p>
<p>这两部分内容都通过 Pintool 这个可执行文件来实现。Pintool 可以看作是 Pin 中可以实现修改代码生成过程的插件。</p>
<p>Pintool 会向 Pin 注册插桩回调例程，每当需要生成新代码时， Pin 会调用这些回调例程。回调例程承担了检测插桩内容的作用，它会检查要生成的代码，检查其静态属性，并决定是否以及在何处注入对分析函数的调用。</p>
<p>分析功能收集有关应用程序的数据。Pin 确保根据需要保存和恢复整数和浮点寄存器状态，并允许将参数传递给函数。</p>
<p>Pintool 还可以为诸如线程创建或 fork 之类的事件注册通知回调例程，这些回调通常用于收集数据或工具初始化和清理。</p>
<p>因为 Pintool 采用的是类似插件的工作机制，所以必须运行在和 Pin 及插桩的可执行文件相同的地址空间内，所以 Pintool 可以访问可执行文件的全部数据，还会与可执行文件共享 fd 和其他进程信息。</p>
<p>在 Pintool 的开发过程中，分析代码的调优比插桩代码更重要，因为插桩代码只执行一次，但是分析代码会调用很多次。</p>
<h3 id="3"><strong><em>3. 插桩粒度</em></strong></h3>
<h4 id="1-trace-instrumentation"><em>1. trace instrumentation</em></h4>
<p>在一个代码序列第一次执行前进行插桩，这种粒度的插桩称为“trace instrumentation”。在这种模式下，Pintool 一次“trace”执行一次检查和插桩，“trace”是指从一个 branch 开始，以一个无条件跳转 branch 结束，包含 call 和 return。</p>
<p>Pin 会保证每个 trace 只有一个顶部入口，但是可能包含多个出口。如果一个分支连接到了一个 trace 的中间位置，Pin 会生成一个以该分支作为开始的新的 trace 。Pin 将 trace 切分成了基本块，每个基本块称为“BBL”，每个 BBL 是一个单一入口、单一出口的指令序列。如果有分支连接到了 BBL 的中间位置，会定义一个新的 BBL 。通常以 BBL 为单位插入分析调用，而不是对每个指令都插入，这样可以降低分析调用的性能消耗。trace instrumentation 通过 TRACE_AddInstrumentFunction API 调用。</p>
<p>因为 Pin 是在程序执行时动态发现程序的执行流，所以 BBL 的概念与传统的基本块的概念有所不同，说明如下：</p>
<pre class="codehilite"><code>swtich(i){
 case 4: total++;
 case 3: total++;
 case 2: total++;
 case 1: total++;
 case 0: 
 default: break;
}</code></pre>


<p>在 IA-32 架构下，会生成如下类似的指令：</p>
<pre class="codehilite"><code>.L7:
    addl   $1, -4(%ebp)
.L6:
    addl   $1, -4(%ebp)
.L5:
    addl   $1, -4(%ebp)
.L4:
    addl   $1, -4(%ebp)</code></pre>


<p>传统基本块的计算方式是会把每个 addl 指令作为一个单独的指令基本块，但是对于 Pin 来说，随着执行不同的 switch cases，Pin 会在 .L7 作为入口（从 .L7 依次向下执行）的时候生成包含所有4个指令的 BBL，在 .L6 输入的时候生成包含3个指令的 BBL，依此类推。所以，在 Pin 的统计方式里，如果代码分支走到了 .L7 ，只会计算一个 Pin BBL，但是4个传统概念上的基本块都被执行了。</p>
<p>Pin 在遇到一些特殊指令的时候会直接作为 trace 的结束位置，生成一个 BBL， 比如 cpuid, popf 以及 REP 为前缀的指令。REP 为前缀的指令都被当作隐式循环处理，在处理完第一次的迭代后，后面的每次迭代都作为一个单独的 BBL ，因此这种情况下，会看到比传统基本块统计方式统计出更多的 BBL。</p>
<h4 id="2-instruction-instrumentation"><em>2. instruction instrumentation</em></h4>
<p>Pintool 会在可执行文件的每条指令都进行插桩，这种模式使得开发者不必过多关注 trace 内部的迭代循环指令，因为如上面所说，包含循环的 trace 内部的特定的 BBL 和指令可能产生多次。instruction instrumentation 通过 <code>INS_AddInstrumentFunction API</code>进行调用。</p>
<h4 id="3-image-instrumentation"><em>3. image instrumentation</em></h4>
<p>通过“caching”插桩请求实现，会有额外的内存空间要求，属于一种“提前插桩”。image instrumentation 模式下，Pintool 在<code>IMG:Image Object</code>第一次加载时，对整个 imgaes 进行检查和插桩， Pintool 可以遍历 image 的 <code>sections：SEC:Section Object</code>，可以是 section 中的 routine：<code>RTN:Routine</code>，还可以是一个 routine 中的 instructions：INS。插入位置可以是例程或指令的前面或后面，都可以实现，使用的 API 为<strong>IMG_AddInstrumentFunction</strong>。</p>
<p>image instrumentation 需要有调试信息来确定 routine 的边界，所以在调用 PIN_Init 之前，需要先初始化符号信息 PIN_InitSysmbols。</p>
<h4 id="4-routine-instrumentation"><em>4. routine instrumentation</em></h4>
<p>通过“caching”插桩请求实现，会有额外的内存空间要求，属于一种“提前插桩”。routine instrumentation 模式下，Pintool 在 image 首次加载时就对整个 routine 进行检查和插桩，对 routine 中的每条指令都可以插桩，但是没有充分的信息可以将指令划分为 BBL。插入位置可以是执行例程或指令的前后。这种模式其实更大程度上属于 image instrumentation 的替代方法，使用的 API 为<code>RTN_AddInstrumentFunction</code>。</p>
<p>需要注意的是，在 image 和 routine instrumentation 模式下，插桩时并不确定 routine 是否会被执行，但是通过识别 routine 的开始指令，可以遍历出执行过的 routine 的指令。</p>
<h3 id="4"><strong><em>4. 符号</em></strong></h3>
<p>Pin 通过symbol object 来访问函数名， 但是 symbol 对象只能提供程序中的函数符号相关的信息，对于数据符号之类的信息必须通过其他工具获取。</p>
<p>Windows下，可以通过<code>dbghelp.dll</code>文件获取，但是可能出现死锁问题；Linux下可以通过 <code>libelf.so</code>或<code>libdwarf.so</code> 文件获取符号信息。</p>
<h2 id="3_1"><strong><em>3. 官方样例</em></strong></h2>
<p>本章主要是通过运行一些 Pin 内置的样例 Pintool，来实际感受一下 Pin 的插桩过程。实践出真知。</p>
<h3 id="1_1"><strong><em>1. 构建样例工具</em></strong></h3>
<p>ia32 架构的样例：</p>
<pre class="codehilite"><code>$ cd source/tools/ManualExamples
$ make all TARGET=ia32</code></pre>


<p>ia64 架构的样例：</p>
<pre class="codehilite"><code>$ cd source/tools/ManualExamples
$ make all TARGET=intel64</code></pre>


<p>编译并运行某个样例：</p>
<pre class="codehilite"><code>$ cd source/tools/ManualExamples
$ make inscount0.test TARGET=intel64</code></pre>


<p>编译某个样例但不运行：</p>
<pre class="codehilite"><code>$ cd source/tools/ManualExamples
$ make obj-intel64/inscount0.so TARGET=intel64
# $ make obj-ia32/inscount0.so TARGET=ia32</code></pre>


<h3 id="2"><strong><em>2. 简单的指令计数（指令插桩）</em></strong></h3>
<p>功能：统计执行过的指令的总数。</p>
<p>运行和查看输出：</p>
<pre class="codehilite"><code>$ ../../../pin -t obj-intel64/inscount0.so -o inscount.out -- /bin/ls
Makefile      atrace.o   imageload.out  itrace    proccount
Makefile.example  imageload   inscount0    itrace.o   proccount.o
atrace       imageload.o  inscount0.o   itrace.out
$ cat inscount.out
Count 422838

# 输出文件存在默认名称，可以使用-o参数指定输出文件名。</code></pre>


<p>原理：在每个指令前插入对 <code>docount</code> 的调用，并将结果保存在<code>inscount.out</code>文件中。</p>
<p>源码 <code>source/tools/ManualExamples/inscount0.cpp</code>：</p>
<pre class="codehilite"><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include "pin.H"

using std::cerr;
using std::endl;
using std::ios;
using std::ofstream;
using std::string;
ofstream OutFile;
// The running count of instructions is kept here
// make it static to help the compiler optimize docount
static UINT64 icount = 0;

// 这里就是我们调用的桩代码
VOID docount() { icount++; }

// Pin calls this function every time a new instruction is encountered
// 遇到一条新指令，调用一次该函数
VOID Instruction(INS ins, VOID* v)
{
  // Insert a call to docount before every instruction, no arguments are passed
  // 指定调用的桩代码函数，执行插入操作，没有对桩代码函数进行传参
  INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)docount, IARG_END);
}

// 处理输出文件，默认文件名为“inscount.out”
KNOB&lt; string &gt; KnobOutputFile(KNOB_MODE_WRITEONCE, "pintool", "o", "inscount.out", "specify output file name");

// This function is called when the application exits
VOID Fini(INT32 code, VOID* v)
{
  // Write to a file since cout and cerr maybe closed by the application
  // 将输出保存到文件*
  OutFile.setf(ios::showbase);
  OutFile &lt;&lt; "Count " &lt;&lt; icount &lt;&lt; endl;
  OutFile.close();
}

/* ===================================================================== */
/* Print Help Message                         */
/* ===================================================================== */
INT32 Usage()
{
  cerr &lt;&lt; "This tool counts the number of dynamic instructions executed" &lt;&lt; endl;
  cerr &lt;&lt; endl &lt;&lt; KNOB_BASE::StringKnobSummary() &lt;&lt; endl;
  return -1;
}
/* ===================================================================== */
/* Main                                  */
/* ===================================================================== */
/*  argc, argv are the entire command line: pin -t &lt;toolname&gt; -- ...   */
/* ===================================================================== */
int main(int argc, char* argv[])
{
  // Initialize pin 初始化
  if (PIN_Init(argc, argv)) return Usage();
  OutFile.open(KnobOutputFile.Value().c_str());

  // Register Instruction to be called to instrument instructions
  // 注册插桩函数
  INS_AddInstrumentFunction(Instruction, 0);

  // Register Fini to be called when the application exits
  // 注册程序退出时的处理函数
  PIN_AddFiniFunction(Fini, 0);

  // Start the program, never returns
  // 开始执行
  PIN_StartProgram();
  return 0;
}</code></pre>


<h3 id="3_2"><strong><em>3. 指令地址跟踪（指令插桩）</em></strong></h3>
<p>功能：打印执行的指令的地址</p>
<p>运行和查看输出：</p>
<pre class="codehilite"><code>$ ../../../pin -t obj-intel64/itrace.so -- /bin/ls
Makefile      atrace.o   imageload.out  itrace    proccount
Makefile.example  imageload   inscount0    itrace.o   proccount.o
atrace       imageload.o  inscount0.o   itrace.out
$ head itrace.out
0x40001e90
0x40001e91
0x40001ee4
0x40001ee5
0x40001ee7
0x40001ee8
0x40001ee9
0x40001eea
0x40001ef0
0x40001ee0
$</code></pre>


<p>原理：在调用分析程序时，Pin 允许传递指令指针、寄存器当前值、内存操作的有效地址、常量等数据给分析程序。完整的可传递的参数的类型如下：<a href="https://software.intel.com/sites/landingpage/pintool/docs/98437/Pin/html/group__INST__ARGS.html#ga089c27ca15e9ff139dd3a3f8a6f8451d">IARG_TYPE</a>。将指令计数程序中的参数更改为 <code>INS_InsertCall</code>来传递即将执行的指令的地址，将<code>docount</code>更改为<code>printip</code>来打印指令的地址，最后将输出写入到文件<code>itrace.out</code> 中。</p>
<p>源码<code>source/tools/ManualExamples/itrace.cpp</code>:</p>
<pre class="codehilite"><code>#include &lt;stdio.h&gt;
#include "pin.H"
FILE* trace;
// 在每条指令执行前都会被调用，打印出当前指令的地址
VOID printip(VOID* ip) { fprintf(trace, "%p\n", ip); }
// 遇到一条新指令调用一次
VOID Instruction(INS ins, VOID* v)
{
    // 在每条指令前插入对 printip 函数的调用，并传递 ip 参数
    INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)printip, IARG_INST_PTR, IARG_END);
}
// 结束函数
VOID Fini(INT32 code, VOID* v)
{
    fprintf(trace, "#eof\n");
    fclose(trace);
}
/* ===================================================================== */
/* Print Help Message                                                    */
/* ===================================================================== */
INT32 Usage()
{
    PIN_ERROR("This Pintool prints the IPs of every instruction executed\n" + KNOB_BASE::StringKnobSummary() + "\n");
    return -1;
}
/* ===================================================================== */
/* Main                                                                  */
/* ===================================================================== */
int main(int argc, char* argv[])
{
    trace = fopen("itrace.out", "w");
    // 初始化
    if (PIN_Init(argc, argv)) return Usage();
    // 桩指令注册
    INS_AddInstrumentFunction(Instruction, 0);
    // 结束逻辑注册
    PIN_AddFiniFunction(Fini, 0);
    // 开始执行，不返回
    PIN_StartProgram();
    return 0;
}</code></pre>


<h3 id="4_1"><strong><em>4. 内存调用跟踪（指令插桩）</em></strong></h3>
<p>功能：内存引用追踪（只对读写内存的指令插桩）</p>
<p>运行和查看输出：</p>
<pre class="codehilite"><code>$ ../../../pin -t obj-intel64/pinatrace.so -- /bin/ls
Makefile      atrace.o   imageload.o   inscount0.o  itrace.out
Makefile.example  atrace.out  imageload.out  itrace    proccount
atrace       imageload  inscount0    itrace.o   proccount.o
$ head pinatrace.out
0x40001ee0: R 0xbfffe798
0x40001efd: W 0xbfffe7d4
0x40001f09: W 0xbfffe7d8
0x40001f20: W 0xbfffe864
0x40001f20: W 0xbfffe868
0x40001f20: W 0xbfffe86c
0x40001f20: W 0xbfffe870
0x40001f20: W 0xbfffe874
0x40001f20: W 0xbfffe878
0x40001f20: W 0xbfffe87c
$</code></pre>


<p>原理：Pin 中包含可以对指令进行分类和检查功能的 API，通过调用该 API 可以实现对某一类功能的函数的追踪。</p>
<p>源码<code>source/tools/ManualExamples/itrace.cpp</code>：</p>
<pre class="codehilite"><code>/*
 *  This file contains an ISA-portable PIN tool for tracing memory accesses.*
 */
#include &lt;stdio.h&gt;
#include "pin.H"
FILE* trace;
// 打印地址读的指令的地址
VOID RecordMemRead(VOID* ip, VOID* addr) { fprintf(trace, "%p: R %p\n", ip, addr); }
// 打印地址写的指令的地址
VOID RecordMemWrite(VOID* ip, VOID* addr) { fprintf(trace, "%p: W %p\n", ip, addr); }
// 使用谓词函数调用来检测内存访问
// 每个读和写的指令都会调用
VOID Instruction(INS ins, VOID* v)
{
  // 获取指令中的内存操作数计数
  UINT32 memOperands = INS_MemoryOperandCount(ins);

  // 遍历指令中的每个内存操作数
  for (UINT32 memOp = 0; memOp &lt; memOperands; memOp++)
  {     
    // 如果是内存读
    if (INS_MemoryOperandIsRead(ins, memOp))
    {
      INS_InsertPredicatedCall(ins, IPOINT_BEFORE, (AFUNPTR)RecordMemRead, IARG_INST_PTR, IARG_MEMORYOP_EA, memOp,
                   IARG_END);
    }

    // 在某些架构下，内存操作数可以同时用作读和写，例如 IA-32 的 %eax，这种情况下只记录一次*
    // 如果是写
   if (INS_MemoryOperandIsWritten(ins, memOp))
    {
     INS_InsertPredicatedCall(ins, IPOINT_BEFORE, (AFUNPTR)RecordMemWrite, IARG_INST_PTR, IARG_MEMORYOP_EA, memOp,
                   IARG_END);
    }
  }
}
VOID Fini(INT32 code, VOID* v)
{
  fprintf(trace, "#eof\n");
  fclose(trace);
}
/* ===================================================================== */
/* Print Help Message                                                    */
/* ===================================================================== */
INT32 Usage()
{
    PIN_ERROR("This Pintool prints a trace of memory addresses\n" + KNOB_BASE::StringKnobSummary() + "\n");
    return -1;
}
/* ===================================================================== */
/* Main                                                                  */
/* ===================================================================== */
int main(int argc, char* argv[])
{
    if (PIN_Init(argc, argv)) return Usage();
    trace = fopen("pinatrace.out", "w");
    // 注册桩函数
    INS_AddInstrumentFunction(Instruction, 0);
    // 注册结束函数
    PIN_AddFiniFunction(Fini, 0);
    // 开始，不返回
    PIN_StartProgram();
    return 0;
}</code></pre>


<h3 id="5-imageimage"><strong><em>5. 检测image的加载和卸载（image插桩）</em></strong></h3>
<p>功能：在 image 加载和卸载时打印信息到 trace 文件中。</p>
<p>执行和查看输出:</p>
<pre class="codehilite"><code>$ ../../../pin -t obj-intel64/imageload.so -- /bin/ls
Makefile      atrace.o   imageload.o   inscount0.o  proccount
Makefile.example  atrace.out  imageload.out  itrace    proccount.o
atrace       imageload  inscount0    itrace.o   trace.out
$ cat imageload.out
Loading /bin/ls
Loading /lib/ld-linux.so.2
Loading /lib/libtermcap.so.2
Loading /lib/i686/libc.so.6
Unloading /bin/ls
Unloading /lib/ld-linux.so.2
Unloading /lib/libtermcap.so.2
Unloading /lib/i686/libc.so.6
$</code></pre>


<p>原理：本质上没有对 image 文件进行插桩。</p>
<p>源码<code>source/tools/ManualExamples/imageload.cpp</code>：</p>
<pre class="codehilite"><code>//
// This tool prints a trace of image load and unload events
//
#include "pin.H"
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;stdlib.h&gt;
using std::endl;
using std::ofstream;
using std::string;
KNOB&lt; string &gt; KnobOutputFile(KNOB_MODE_WRITEONCE, "pintool", "o", "imageload.out", "specify file name");
ofstream TraceFile;

// Pin 在 image 加载时调用该函数，在该例中没有进行插桩
VOID ImageLoad(IMG img, VOID* v) { TraceFile &lt;&lt; "Loading " &lt;&lt; IMG_Name(img) &lt;&lt; ", Image id = " &lt;&lt; IMG_Id(img) &lt;&lt; endl; }
// Pin 在 image 卸载时调用该函数，对于将要卸载的image无法进行插桩
VOID ImageUnload(IMG img, VOID* v) { TraceFile &lt;&lt; "Unloading " &lt;&lt; IMG_Name(img) &lt;&lt; endl; }
// This function is called when the application exits
// It closes the output file.
VOID Fini(INT32 code, VOID* v)
{
    if (TraceFile.is_open())
    {
        TraceFile.close();
    }
}
/* ===================================================================== */
/* Print Help Message                                                    */
/* ===================================================================== */
INT32 Usage()
{
    PIN_ERROR("This tool prints a log of image load and unload events\n" + KNOB_BASE::StringKnobSummary() + "\n");
    return -1;
}
/* ===================================================================== */
/* Main                                                                  */
/* ===================================================================== */
int main(int argc, char* argv[])
{
    // 符号初始化
    PIN_InitSymbols();
    // pin 初始化
    if (PIN_Init(argc, argv)) return Usage();
    TraceFile.open(KnobOutputFile.Value().c_str());
    // 注册加载桩函数
    IMG_AddInstrumentFunction(ImageLoad, 0);
    // 注册卸载桩函数
    IMG_AddUnloadFunction(ImageUnload, 0);
    // 注册退出函数
    PIN_AddFiniFunction(Fini, 0);
    // 开始执行，无返回
    PIN_StartProgram();
    return 0;
}</code></pre>


<h3 id="6-trace"><strong><em>6. 进阶版指令计数（trace 插桩）</em></strong></h3>
<p>功能：计算 BBL （单入口单出口）数量</p>
<p>执行和查看输出：</p>
<pre class="codehilite"><code>$ ../../../pin -t obj-intel64/inscount1.so -o inscount.out -- /bin/ls
Makefile      atrace.o   imageload.out  itrace    proccount
Makefile.example  imageload   inscount0    itrace.o   proccount.o
atrace       imageload.o  inscount0.o   itrace.out
$ cat inscount.out
Count 707208 </code></pre>


<p>原理：在每个 BBL 进行插桩来替代在每个指令进行插桩，在进行计数时，以 bbl 为单位，每次增加每个 bbl 中的指令数量。</p>
<p>源码 <code>source/tools/ManualExamples/inscount1.cpp</code>：</p>
<pre class="codehilite"><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include "pin.H"
using std::cerr;
using std::endl;
using std::ios;
using std::ofstream;
using std::string;
ofstream OutFile;
// 保存指令的运行次数，设置为静态变量以帮助编译器优化 docount
static UINT64 icount = 0;
// 在每个 block 前都会被调用
VOID docount(UINT32 c) { icount += c; }
// Pin 在遇到一个新的block 时进行调用，插入对 docount 函数的调用
VOID Trace(TRACE trace, VOID* v)
{
    // 访问 trace 中的每个 bbl
    for (BBL bbl = TRACE_BblHead(trace); BBL_Valid(bbl); bbl = BBL_Next(bbl))
    {
        // 在每个 bbl 前插入对 docount 函数的调用，传入指令数量
        BBL_InsertCall(bbl, IPOINT_BEFORE, (AFUNPTR)docount, IARG_UINT32, BBL_NumIns(bbl), IARG_END);
    }
}
KNOB&lt; string &gt; KnobOutputFile(KNOB_MODE_WRITEONCE, "pintool", "o", "inscount.out", "specify output file name");
// 退出函数
VOID Fini(INT32 code, VOID* v)
{
    // 写入到文件中，程序可能会关闭 cout 和 cerr
    OutFile.setf(ios::showbase);
    OutFile &lt;&lt; "Count " &lt;&lt; icount &lt;&lt; endl;
    OutFile.close();
}
/* ===================================================================== */
/* Print Help Message                                                    */
/* ===================================================================== */
INT32 Usage()
{
    cerr &lt;&lt; "This tool counts the number of dynamic instructions executed" &lt;&lt; endl;
    cerr &lt;&lt; endl &lt;&lt; KNOB_BASE::StringKnobSummary() &lt;&lt; endl;
    return -1;
}
/* ===================================================================== */
/* Main                                                                  */
/* ===================================================================== */
int main(int argc, char* argv[])
{
    // 初始化 pin
    if (PIN_Init(argc, argv)) return Usage();
    OutFile.open(KnobOutputFile.Value().c_str());
    // 注册插桩函数
    TRACE_AddInstrumentFunction(Trace, 0);
    // 注册退出函数
    PIN_AddFiniFunction(Fini, 0);
    // 开始执行，不返回
    PIN_StartProgram();
    return 0;
}</code></pre>


<h3 id="7-procedure-routine"><strong><em>7. Procedure 指令计数（routine插桩）</em></strong></h3>
<p>功能：计算一个 procedure 被调用的次数，以及每个 procedure 中执行的命令总数。</p>
<p>执行和检查输出：</p>
<pre class="codehilite"><code>$ ../../../pin -t obj-intel64/proccount.so -- /bin/grep proccount.cpp Makefile
proccount_SOURCES = proccount.cpp
$ head proccount.out
       Procedure      Image       Address     Calls Instructions
         _fini    libc.so.6     0x40144d00       1      21
__deregister_frame_info    libc.so.6     0x40143f60       2      70
 __register_frame_info    libc.so.6     0x40143df0       2      62
       fde_merge    libc.so.6     0x40143870       0       8
      __init_misc    libc.so.6     0x40115824       1      85
      __getclktck    libc.so.6     0x401157f4       0       2
         munmap    libc.so.6     0x40112ca0       1       9
          mmap    libc.so.6     0x40112bb0       1      23
      getpagesize    libc.so.6     0x4010f934       2      26
$</code></pre>


<p>源码 <code>source/tools/ManualExamples/proccount.cpp</code>：</p>
<pre class="codehilite"><code>//
// This tool counts the number of times a routine is executed and
// the number of instructions executed in a routine
//
#include &lt;fstream&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include "pin.H"
using std::cerr;
using std::dec;
using std::endl;
using std::hex;
using std::ofstream;
using std::setw;
using std::string;
ofstream outFile;
// 保存 procedure 的指令数
typedef struct RtnCount
{
    string _name;
    string _image;
    ADDRINT _address;
    RTN _rtn;
    UINT64 _rtnCount;
    UINT64 _icount;
    struct RtnCount* _next;
} RTN_COUNT;
// 每个 procedure 的指令数的链表
RTN_COUNT* RtnList = 0;
// 每条指令执行前调用
VOID docount(UINT64* counter) { (*counter)++; }
const char* StripPath(const char* path)
{
    const char* file = strrchr(path, '/');
    if (file)
        return file + 1;
    else
        return path;
}
// Pin 在一个新的 rtn 执行时调用该函数
VOID Routine(RTN rtn, VOID* v)
{
    // 对该routine设置一个计数器
    RTN_COUNT* rc = new RTN_COUNT;
    // image unloaded 时， RTN 数据消失，所以在此处直接保存，后续 fini 中还要使用
    rc-&gt;_name     = RTN_Name(rtn);
    rc-&gt;_image    = StripPath(IMG_Name(SEC_Img(RTN_Sec(rtn))).c_str());
    rc-&gt;_address  = RTN_Address(rtn);
    rc-&gt;_icount   = 0;
    rc-&gt;_rtnCount = 0;
    // 添加到routines列表
    rc-&gt;_next = RtnList;
    RtnList   = rc;
    RTN_Open(rtn);
    // 在routine入口处插入一个call，增加call计数
    RTN_InsertCall(rtn, IPOINT_BEFORE, (AFUNPTR)docount, IARG_PTR, &amp;(rc-&gt;_rtnCount), IARG_END);
    // 对于routine中的每条指令
    for (INS ins = RTN_InsHead(rtn); INS_Valid(ins); ins = INS_Next(ins))
    {
        // 插入对docount函数的调用，增加该rtn中的指令计数
        INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)docount, IARG_PTR, &amp;(rc-&gt;_icount), IARG_END);
    }
    RTN_Close(rtn);
}
// 退出函数，打印每个procedure的名字和计数
VOID Fini(INT32 code, VOID* v)
{
    outFile &lt;&lt; setw(23) &lt;&lt; "Procedure"
            &lt;&lt; " " &lt;&lt; setw(15) &lt;&lt; "Image"
            &lt;&lt; " " &lt;&lt; setw(18) &lt;&lt; "Address"
            &lt;&lt; " " &lt;&lt; setw(12) &lt;&lt; "Calls"
            &lt;&lt; " " &lt;&lt; setw(12) &lt;&lt; "Instructions" &lt;&lt; endl;
    for (RTN_COUNT* rc = RtnList; rc; rc = rc-&gt;_next)
    {
        if (rc-&gt;_icount &gt; 0)
            outFile &lt;&lt; setw(23) &lt;&lt; rc-&gt;_name &lt;&lt; " " &lt;&lt; setw(15) &lt;&lt; rc-&gt;_image &lt;&lt; " " &lt;&lt; setw(18) &lt;&lt; hex &lt;&lt; rc-&gt;_address &lt;&lt; dec
                    &lt;&lt; " " &lt;&lt; setw(12) &lt;&lt; rc-&gt;_rtnCount &lt;&lt; " " &lt;&lt; setw(12) &lt;&lt; rc-&gt;_icount &lt;&lt; endl;
    }
}
/* ===================================================================== */
/* Print Help Message                                                    */
/* ===================================================================== */
INT32 Usage()
{
    cerr &lt;&lt; "This Pintool counts the number of times a routine is executed" &lt;&lt; endl;
    cerr &lt;&lt; "and the number of instructions executed in a routine" &lt;&lt; endl;
    cerr &lt;&lt; endl &lt;&lt; KNOB_BASE::StringKnobSummary() &lt;&lt; endl;
    return -1;
}
/* ===================================================================== */
/* Main                                                                  */
/* ===================================================================== */
int main(int argc, char* argv[])
{
    PIN_InitSymbols();
    outFile.open("proccount.out");

    if (PIN_Init(argc, argv)) return Usage();
    // 注册桩函数
    RTN_AddInstrumentFunction(Routine, 0);
    // 注册程序退出时的 fini函数
    PIN_AddFiniFunction(Fini, 0);
    // 开始执行，不返回
    PIN_StartProgram();
    return 0;
}</code></pre>


<p><strong><em>下面是一些Pin的功能性特征说明样例。</em></strong></p>
<h3 id="8-pin_safecopy-api"><strong><em>8. PIN_SafeCopy() API</em></strong></h3>
<p>功能：从源内存区域复制指定数量的字节数到目的内存区域。即使源或目的区域不可访问，此函数也可保证安全返回给caller。此外，该API还可以读写程序的内存数据。</p>
<p>执行和查看输出：</p>
<pre class="codehilite"><code>$ ../../../pin -t obj-ia32/safecopy.so -- /bin/cp makefile obj-ia32/safecopy.so.makefile.copy
$ head safecopy.out
Emulate loading from addr 0xbff0057c to ebx
Emulate loading from addr 0x64ffd4 to eax
Emulate loading from addr 0xbff00598 to esi
Emulate loading from addr 0x6501c8 to edi
Emulate loading from addr 0x64ff14 to edx
Emulate loading from addr 0x64ff1c to edx
Emulate loading from addr 0x64ff24 to edx
Emulate loading from addr 0x64ff2c to edx
Emulate loading from addr 0x64ff34 to edx
Emulate loading from addr 0x64ff3c to edx</code></pre>


<p>源码<code>source/tools/ManualExamples/safecopy.cpp</code>:</p>
<pre class="codehilite"><code>\#include &lt;stdio.h&gt;
\#include "pin.H"
\#include &lt;iostream&gt;
\#include &lt;fstream&gt;
using std::cerr;
using std::endl;
std::ofstream* out = 0;
//=======================================================
//  Analysis routines
//=======================================================
// 从内存转移到寄存器中
ADDRINT DoLoad(REG reg, ADDRINT* addr)
{
  *out &lt;&lt; "Emulate loading from addr " &lt;&lt; addr &lt;&lt; " to " &lt;&lt; REG_StringShort(reg) &lt;&lt; endl;
  ADDRINT value;
  PIN_SafeCopy(&amp;value, addr, **sizeof**(ADDRINT));
  return value;
}
//=======================================================
// Instrumentation routines
//=======================================================
VOID EmulateLoad(INS ins, VOID* v)
{
  // Find the instructions that move a value from memory to a register
  if (INS_Opcode(ins) == XED_ICLASS_MOV &amp;&amp; INS_IsMemoryRead(ins) &amp;&amp; INS_OperandIsReg(ins, 0) &amp;&amp; INS_OperandIsMemory(ins, 1))
  {
    // op0 &lt;- \*op1
    INS_InsertCall(ins, IPOINT_BEFORE, AFUNPTR(DoLoad), IARG_UINT32, REG(INS_OperandReg(ins, 0)), IARG_MEMORYREAD_EA,IARG_RETURN_REGS, INS_OperandReg(ins, 0), IARG_END);
    // Delete the instruction
    INS_Delete(ins);
  }
}
/* ===================================================================== */
/* Print Help Message                           */
/* ===================================================================== */
INT32 Usage()
{
  cerr &lt;&lt; "This tool demonstrates the use of SafeCopy" &lt;&lt; endl;
  cerr &lt;&lt; endl &lt;&lt; KNOB_BASE::StringKnobSummary() &lt;&lt; endl;
  return -1;
}
/* ===================================================================== */
/* Main                                  */
/* ===================================================================== */
int main(int argc, char* argv[])
{
  // Write to a file since cout and cerr maybe closed by the application
  out = new std::ofstream("safecopy.out");
  // 初始化Pin，初始化符号
  if (PIN_Init(argc, argv)) return Usage();
  PIN_InitSymbols();
  // 注册EmulateLoad函数以进行插桩
  INS_AddInstrumentFunction(EmulateLoad, 0);
  // 开始执行，不返回
  PIN_StartProgram();
  return 0;
}</code></pre>


<h3 id="9"><strong><em>9. 插桩顺序</em></strong></h3>
<p>Pin提供了多种方式来控制analysis call的执行顺序，主要取决于insertion action(IPOINT)和call order(CALL_ORDER)。</p>
<p>执行和查看输出：</p>
<pre class="codehilite"><code>$ ../../../pin -t obj-ia32/invocation.so -- obj-ia32/little_malloc
$ head invocation.out
After: IP = 0x64bc5e
Before: IP = 0x64bc5e
Taken: IP = 0x63a12e
After: IP = 0x64bc5e
Before: IP = 0x64bc5e
Taken: IP = 0x641c76
After: IP = 0x641ca6
After: IP = 0x64bc5e
Before: IP = 0x64bc5e
Taken: IP = 0x648b02</code></pre>


<p>源码<code>source/tools/ManualExamples/invocation.cpp</code>：</p>
<pre class="codehilite"><code>#include "pin.H"
#include &lt;iostream&gt;
#include &lt;fstream&gt;
using std::cerr;
using std::dec;
using std::endl;
using std::hex;
using std::ios;
using std::ofstream;
using std::string;
KNOB&lt; string &gt; KnobOutputFile(KNOB_MODE_WRITEONCE, "pintool", "o", "invocation.out", "specify output file name");
ofstream OutFile;
/*
 * Analysis routines
 */
VOID Taken(const CONTEXT* ctxt)
{
    ADDRINT TakenIP = (ADDRINT)PIN_GetContextReg(ctxt, REG_INST_PTR);
    OutFile &lt;&lt; "Taken: IP = " &lt;&lt; hex &lt;&lt; TakenIP &lt;&lt; dec &lt;&lt; endl;
}
VOID Before(CONTEXT* ctxt)
{
    ADDRINT BeforeIP = (ADDRINT)PIN_GetContextReg(ctxt, REG_INST_PTR);
    OutFile &lt;&lt; "Before: IP = " &lt;&lt; hex &lt;&lt; BeforeIP &lt;&lt; dec &lt;&lt; endl;
}
VOID After(CONTEXT* ctxt)
{
    ADDRINT AfterIP = (ADDRINT)PIN_GetContextReg(ctxt, REG_INST_PTR);
    OutFile &lt;&lt; "After: IP = " &lt;&lt; hex &lt;&lt; AfterIP &lt;&lt; dec &lt;&lt; endl;
}
/*
 * Instrumentation routines
 */
VOID ImageLoad(IMG img, VOID* v)
{
    for (SEC sec = IMG_SecHead(img); SEC_Valid(sec); sec = SEC_Next(sec))
    {
        // RTN_InsertCall()和INS_InsertCall()谁先出现谁先执行
        // 在下面的代码中，IPOINT_AFTER在IPOINT_BEFORE之前执行。
        for (RTN rtn = SEC_RtnHead(sec); RTN_Valid(rtn); rtn = RTN_Next(rtn))
        {
            // 打开RTN.
            RTN_Open(rtn);
            // IPOINT_AFTER通过在一个routine中对每个return指令插桩实现。
            // Pin会尝试查找所有的return指令，成不成功则是另外一回事（有点可爱23333）。
            RTN_InsertCall(rtn, IPOINT_AFTER, (AFUNPTR)After, IARG_CONTEXT, IARG_END);
            // 检查routine中的每条指令
            for (INS ins = RTN_InsHead(rtn); INS_Valid(ins); ins = INS_Next(ins))
            {
                if (INS_IsRet(ins))
                {
                    // 插桩每条return指令
                    // IPOINT_TAKEN_BRANCH总是最后使用
                    INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)Before, IARG_CONTEXT, IARG_END);
                    INS_InsertCall(ins, IPOINT_TAKEN_BRANCH, (AFUNPTR)Taken, IARG_CONTEXT, IARG_END);
                }
            }
            // 关闭RTN.
            RTN_Close(rtn);
        }
    }
}
VOID Fini(INT32 code, VOID* v) { OutFile.close(); }
/* ===================================================================== */
/* Print Help Message                                                    */
/* ===================================================================== */
INT32 Usage()
{
    cerr &lt;&lt; "This is the invocation pintool" &lt;&lt; endl;
    cerr &lt;&lt; endl &lt;&lt; KNOB_BASE::StringKnobSummary() &lt;&lt; endl;
    return -1;
}
/* ===================================================================== */
/* Main                                                                  */
/* ===================================================================== */
int main(int argc, char* argv[])
{
    //  初始化
    if (PIN_Init(argc, argv)) return Usage();
    PIN_InitSymbols();
    // 注册ImageLoad函数
    IMG_AddInstrumentFunction(ImageLoad, 0);
    PIN_AddFiniFunction(Fini, 0);
    // 写入到文件
    OutFile.open(KnobOutputFile.Value().c_str());
    OutFile.setf(ios::showbase);
    // 开始执行，无返回
    PIN_StartProgram();
    return 0;
}</code></pre>


<h3 id="10"><strong><em>10. 查看函数参数值</em></strong></h3>
<p>功能：使用RTN_InsertCall()查看函数参数</p>
<p>执行和查看输出：</p>
<pre class="codehilite"><code>$ ../../../pin -t obj-intel64/malloctrace.so -- /bin/cp makefile obj-intel64/malloctrace.so.makefile.copy
$ cat malloctrace.out
malloc(0x5a1)
 returns 0x7f87d8ce2190
malloc(0x4a1)
 returns 0x7f87d8ce2740
malloc(0x10)
 returns 0x7f87d8ce2bf0
malloc(0x9d)
 returns 0x7f87d8ce2c00
malloc(0x28)
 returns 0x7f87d8ce2ca0
malloc(0x140)
 returns 0x7f87d8ce2cd0
malloc(0x26)
 returns 0x7f87d8ce2e10
free(0)
malloc(0x4b0)
 returns 0x7f87c4428000
malloc(0x26)
 returns 0x7f87c44284b0
malloc(0x22)
 returns 0x7f87c44284e0
free(0)
... ...</code></pre>


<p>源码<code>source/tools/ManualExamples/malloctrace.cpp</code>:</p>
<pre class="codehilite"><code>#include "pin.H"
#include &lt;iostream&gt;
#include &lt;fstream&gt;
using std::cerr;
using std::endl;
using std::hex;
using std::ios;
using std::string;
/* ===================================================================== */
/* Names of malloc and free */
/* ===================================================================== */
#if defined(TARGET_MAC)
#define MALLOC "_malloc"
#define FREE "_free"
#else
#define MALLOC "malloc"
#define FREE "free"
#endif
/* ===================================================================== */
/* Global Variables */
/* ===================================================================== */
std::ofstream TraceFile;
/* ===================================================================== */
/* Commandline Switches */
/* ===================================================================== */
KNOB&lt; string &gt; KnobOutputFile(KNOB_MODE_WRITEONCE, "pintool", "o", "malloctrace.out", "specify trace file name");
/* ===================================================================== */

/* ===================================================================== */
/* Analysis routines                                                     */
/* ===================================================================== */
VOID Arg1Before(CHAR* name, ADDRINT size) { TraceFile &lt;&lt; name &lt;&lt; "(" &lt;&lt; size &lt;&lt; ")" &lt;&lt; endl; }
VOID MallocAfter(ADDRINT ret) { TraceFile &lt;&lt; "  returns " &lt;&lt; ret &lt;&lt; endl; }

/* ===================================================================== */
/* Instrumentation routines                                              */
/* ===================================================================== */
VOID Image(IMG img, VOID* v)
{
    // 对malloc和free函数进行插桩，打印出每个malloc或free函数的输入参数以及malloc的返回值
    // 首先，查找malloc函数
    RTN mallocRtn = RTN_FindByName(img, MALLOC);
    if (RTN_Valid(mallocRtn))
    {
        RTN_Open(mallocRtn);
        // 对查找到的malloc()函数进行插桩打印其参数
        RTN_InsertCall(mallocRtn, IPOINT_BEFORE, (AFUNPTR)Arg1Before, IARG_ADDRINT, MALLOC, IARG_FUNCARG_ENTRYPOINT_VALUE, 0,IARG_END);
        // 打印返回值
        RTN_InsertCall(mallocRtn, IPOINT_AFTER, (AFUNPTR)MallocAfter, IARG_FUNCRET_EXITPOINT_VALUE, IARG_END);
        RTN_Close(mallocRtn);
    }
    // 查找free()
    RTN freeRtn = RTN_FindByName(img, FREE);
    if (RTN_Valid(freeRtn))
    {
        RTN_Open(freeRtn);
        // 插桩，打印输入参数
        RTN_InsertCall(freeRtn, IPOINT_BEFORE, (AFUNPTR)Arg1Before, IARG_ADDRINT, FREE, IARG_FUNCARG_ENTRYPOINT_VALUE, 0,
                       IARG_END);
        RTN_Close(freeRtn);
    }
}
VOID Fini(INT32 code, VOID* v) { TraceFile.close(); }
/* Print Help Message                                                    */
INT32 Usage()
{
    cerr &lt;&lt; "This tool produces a trace of calls to malloc." &lt;&lt; endl;
    cerr &lt;&lt; endl &lt;&lt; KNOB_BASE::StringKnobSummary() &lt;&lt; endl;
    return -1;
}
/* ===================================================================== */
/* Main                                                                  */
/* ===================================================================== */
int main(int argc, char* argv[])
{
    // 初始化
    PIN_InitSymbols();
    if (PIN_Init(argc, argv))
    {
        return Usage();
    }
    // 写入到文件
    TraceFile.open(KnobOutputFile.Value().c_str());
    TraceFile &lt;&lt; hex;
    TraceFile.setf(ios::showbase);
    // 注册Image函数
    IMG_AddInstrumentFunction(Image, 0);
    PIN_AddFiniFunction(Fini, 0);
    // 开始执行，不返回
    PIN_StartProgram();
    return 0;
}</code></pre>


<h3 id="11"><strong><em>11. 插桩线程应用</em></strong></h3>
<p>功能：在应用开启了线程环境下进行插桩，使用的callback为ThreadStart()和ThreadFini()。在使用时，为了防止与其他分析routine发生共享资源竞争的问题，可以使用PIN_GetLock()函数进行加锁处理。</p>
<p>执行和查看输出：</p>
<pre class="codehilite"><code>$ ../../../pin -t obj-ia32/malloc_mt.so -- obj-ia32/thread_lin
$ head malloc_mt.out
thread begin 0
thread 0 entered malloc(24d)
thread 0 entered malloc(57)
thread 0 entered malloc(c)
thread 0 entered malloc(3c0)
thread 0 entered malloc(c)
thread 0 entered malloc(58)
thread 0 entered malloc(56)
thread 0 entered malloc(19)
thread 0 entered malloc(25c)</code></pre>


<p>源码<code>source/tools/ManualExamples/malloc_mt.cpp</code>：</p>
<pre class="codehilite"><code>#include &lt;stdio.h&gt;
#include "pin.H"
using std::string;
KNOB&lt; string &gt; KnobOutputFile(KNOB_MODE_WRITEONCE, "pintool", "o", "malloc_mt.out", "specify output file name");
//==============================================================
//  Analysis Routines
//==============================================================
// Note:  threadid+1 作为PIN_GetLock()的参数使用，它的值也就是lock的值，所以不能为0
// lock会序列化对输出文件的访问。
FILE* out;
PIN_LOCK pinLock;

// 每次创建线程，该routine都会被调用执行。
VOID ThreadStart(THREADID threadid, CONTEXT* ctxt, INT32 flags, VOID* v)
{
    PIN_GetLock(&amp;pinLock, threadid + 1); // 加锁
    fprintf(out, "thread begin %d\n", threadid);
    fflush(out);
    PIN_ReleaseLock(&amp;pinLock);  // 解锁
}
// 每次销毁线程，该routine都会被调用执行
VOID ThreadFini(THREADID threadid, const CONTEXT* ctxt, INT32 code, VOID* v)
{
    PIN_GetLock(&amp;pinLock, threadid + 1);
    fprintf(out, "thread end %d code %d\n", threadid, code);
    fflush(out);
    PIN_ReleaseLock(&amp;pinLock);
}
// 每次调用malloc函数，该routine都会被调用执行
VOID BeforeMalloc(int size, THREADID threadid)
{
    PIN_GetLock(&amp;pinLock, threadid + 1);
    fprintf(out, "thread %d entered malloc(%d)\n", threadid, size);
    fflush(out);
    PIN_ReleaseLock(&amp;pinLock);
}
//====================================================================
// Instrumentation Routines
//====================================================================
// 对每个image都执行
VOID ImageLoad(IMG img, VOID*)
{
    RTN rtn = RTN_FindByName(img, "malloc");
    if (RTN_Valid(rtn))
    {
        RTN_Open(rtn);
        RTN_InsertCall(rtn, IPOINT_BEFORE, AFUNPTR(BeforeMalloc), IARG_FUNCARG_ENTRYPOINT_VALUE, 0, IARG_THREAD_ID, IARG_END);
        RTN_Close(rtn);
    }
}
// 在结束时执行一次
VOID Fini(INT32 code, VOID* v) { fclose(out); }
/* ===================================================================== */
/* Print Help Message                                                    */
/* ===================================================================== */
INT32 Usage()
{
    PIN_ERROR("This Pintool prints a trace of malloc calls in the guest application\n" + KNOB_BASE::StringKnobSummary() + "\n");
    return -1;
}
/* ===================================================================== */
/* Main                                                                  */
/* ===================================================================== */
int main(INT32 argc, CHAR** argv)
{
    // 初始化pin的lock
    PIN_InitLock(&amp;pinLock);
    // 初始化pin
    if (PIN_Init(argc, argv)) return Usage();
    PIN_InitSymbols();
    out = fopen(KnobOutputFile.Value().c_str(), "w");
    // 注册ImageLoad函数
    IMG_AddInstrumentFunction(ImageLoad, 0);
    // 注册线程创建或结束时的分析routine
    PIN_AddThreadStartFunction(ThreadStart, 0);
    PIN_AddThreadFiniFunction(ThreadFini, 0);
    // 注册程序退出时的fini函数
    PIN_AddFiniFunction(Fini, 0);
    // 开始执行，不返回
    PIN_StartProgram();
    return 0;
}</code></pre>


<h3 id="12-tlsthread-local-storage"><strong><em>12. 使用TLS(Thread Local Storage)</em></strong></h3>
<p>功能：可以使工具创建线程特定的数据</p>
<p>执行和查看输出：</p>
<pre class="codehilite"><code>$ ../../../pin -t obj-ia32/inscount_tls.so -- obj-ia32/thread_lin
$ head
Count[0]= 237993
Count[1]= 213296
Count[2]= 209223
Count[3]= 209223
Count[4]= 209223
Count[5]= 209223
Count[6]= 209223
Count[7]= 209223
Count[8]= 209223
Count[9]= 209223</code></pre>


<p>源码<code>source/tools/ManualExamples/inscount_tls.cpp</code>：</p>
<pre class="codehilite"><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include "pin.H"
using std::cerr;
using std::cout;
using std::endl;
using std::ostream;
using std::string;
KNOB&lt; string &gt; KnobOutputFile(KNOB_MODE_WRITEONCE, "pintool", "o", "", "specify output file name");
INT32 numThreads = 0;
ostream* OutFile = NULL;
// 强制每个线程的数据存储在自己的数据缓存行中，确保多线程不会发生同一数据缓存行的竞争问题。
// 避免错误共享的问题。
#define PADSIZE 56 // 64 byte line size: 64-8
// 运行的指令计数
class thread_data_t
{
  public:
    thread_data_t() : _count(0) {}
    UINT64 _count;
    UINT8 _pad[PADSIZE];
};
// 存储在线程中的访问TLS的key，只在main函数中初始化一次
static TLS_KEY tls_key = INVALID_TLS_KEY;
// 该函数在每个block前调用
VOID PIN_FAST_ANALYSIS_CALL docount(UINT32 c, THREADID threadid)
{
    thread_data_t* tdata = static_cast&lt; thread_data_t* &gt;(PIN_GetThreadData(tls_key, threadid));
    tdata-&gt;_count += c;
}
VOID ThreadStart(THREADID threadid, CONTEXT* ctxt, INT32 flags, VOID* v)
{
    numThreads++;
    thread_data_t* tdata = new thread_data_t;
    if (PIN_SetThreadData(tls_key, tdata, threadid) == FALSE)
    {
        cerr &lt;&lt; "PIN_SetThreadData failed" &lt;&lt; endl;
        PIN_ExitProcess(1);
    }
}
// 遇到新的代码块时调用，插入对docount函数的调用
VOID Trace(TRACE trace, VOID* v)
{
    // 检查trace中的每个基本块
    for (BBL bbl = TRACE_BblHead(trace); BBL_Valid(bbl); bbl = BBL_Next(bbl))
    {
        // 对每个bbl插入对docount的调用，并传递参数：指令的数量
        BBL_InsertCall(bbl, IPOINT_ANYWHERE, (AFUNPTR)docount, IARG_FAST_ANALYSIS_CALL, IARG_UINT32, BBL_NumIns(bbl),
                       IARG_THREAD_ID, IARG_END);
    }
}
// 线程退出时调用
VOID ThreadFini(THREADID threadIndex, const CONTEXT* ctxt, INT32 code, VOID* v)
{
    thread_data_t* tdata = static_cast&lt; thread_data_t* &gt;(PIN_GetThreadData(tls_key, threadIndex));
    *OutFile &lt;&lt; "Count[" &lt;&lt; decstr(threadIndex) &lt;&lt; "] = " &lt;&lt; tdata-&gt;_count &lt;&lt; endl;
    delete tdata;
}
// 程序退出时调用
VOID Fini(INT32 code, VOID* v) { *OutFile &lt;&lt; "Total number of threads = " &lt;&lt; numThreads &lt;&lt; endl; }
/* ===================================================================== */
/* Print Help Message                                                    */
/* ===================================================================== */
INT32 Usage()
{
    cerr &lt;&lt; "This tool counts the number of dynamic instructions executed" &lt;&lt; endl;
    cerr &lt;&lt; endl &lt;&lt; KNOB_BASE::StringKnobSummary() &lt;&lt; endl;
    return 1;
}
/* ===================================================================== */
/* Main                                                                  */
/* ===================================================================== */
int main(int argc, char* argv[])
{
    PIN_InitSymbols();
    if (PIN_Init(argc, argv)) return Usage();
    OutFile = KnobOutputFile.Value().empty() ? &amp;cout : new std::ofstream(KnobOutputFile.Value().c_str());
    // 设置key
    tls_key = PIN_CreateThreadDataKey(NULL);
    if (tls_key == INVALID_TLS_KEY)
    {
        cerr &lt;&lt; "number of already allocated keys reached the MAX_CLIENT_TLS_KEYS limit" &lt;&lt; endl;
        PIN_ExitProcess(1);
    }
    // 注册线程创建时调用的ThreadStart函数
    PIN_AddThreadStartFunction(ThreadStart, NULL);
    // 注册线程结束时调用的ThreadFini函数
    PIN_AddThreadFiniFunction(ThreadFini, NULL);
    // 注册程序结束时的Fini函数
    PIN_AddFiniFunction(Fini, NULL);
    // 注册指令插桩时调用的Trace函数
    TRACE_AddInstrumentFunction(Trace, NULL);
    // Start the program, never returns
    PIN_StartProgram();
    return 1;
}</code></pre>


<h3 id="13-image"><strong><em>13. 查看image的静态属性</em></strong></h3>
<p>功能：不对binary文件进行插桩，静态获取文件的指令数量。</p>
<p>源码<code>source/tools/ManualExamples/staticcount.cpp</code>：</p>
<pre class="codehilite"><code>//
// This tool prints a trace of image load and unload events
//
#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include "pin.H"
using std::cerr;
using std::endl;
// 在img加载时调用该函数，计算image中的静态指令数量
VOID ImageLoad(IMG img, VOID* v)
{
    UINT32 count = 0;
    for (SEC sec = IMG_SecHead(img); SEC_Valid(sec); sec = SEC_Next(sec))
    {
        for (RTN rtn = SEC_RtnHead(sec); RTN_Valid(rtn); rtn = RTN_Next(rtn))
        {
            // 准备处理RTN，RTN并不会分解成bbl，只是INS的一个序列
            RTN_Open(rtn);
            for (INS ins = RTN_InsHead(rtn); INS_Valid(ins); ins = INS_Next(ins))
            {
                count++;
            }
            // 在处理完与RTN相关的数据后就进行释放，以节省空间
            RTN_Close(rtn);
        }
    }
    fprintf(stderr, "Image %s has  %d instructions\n", IMG_Name(img).c_str(), count);
}
/* ===================================================================== */
/* Print Help Message                                                    */
/* ===================================================================== */
INT32 Usage()
{
    cerr &lt;&lt; "This tool prints a log of image load and unload events" &lt;&lt; endl;
    cerr &lt;&lt; " along with static instruction counts for each image." &lt;&lt; endl;
    cerr &lt;&lt; endl &lt;&lt; KNOB_BASE::StringKnobSummary() &lt;&lt; endl;
    return -1;
}
/* ===================================================================== */
/* Main                                                                  */
/* ===================================================================== */
int main(int argc, char* argv[])
{
    // 初始化符号
    PIN_InitSymbols();
    // 初始化pin
    if (PIN_Init(argc, argv)) return Usage();
    // 注册img加载后要调用的ImageLoad函数
    IMG_AddInstrumentFunction(ImageLoad, 0);
    // 开始执行，不返回
    PIN_StartProgram();
    return 0;
}</code></pre>


<h3 id="14"><strong><em>14. 插桩子进程</em></strong></h3>
<p>功能：在通过execv类命令获得进程开始前执行自定义的函数。</p>
<p>执行和查看输出：在执行时添加<code>-follow_execv</code>选项。</p>
<pre class="codehilite"><code>$ ../../../pin -follow_execv -t obj-intel64/follow_child_tool.so -- obj-intel64/follow_child_app1 obj-intel64/follow_child_app2

$ make follow_child_tool.test</code></pre>


<p><img alt="" src="./Pin 学习参考手册( See Bug 出品)_files/e1552736-2035-473f-b7ea-202cef80d00b.jpg-w331s"></p>
<p>源码<code>source/tools/ManualExamples/follow_child_tool.cpp</code>：</p>
<pre class="codehilite"><code>#include "pin.H"
#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
/* ===================================================================== */
/* Command line Switches */
/* ===================================================================== */
BOOL FollowChild(CHILD_PROCESS cProcess, VOID* userData)
{
    fprintf(stdout, "before child:%u\n", getpid());
    return TRUE;
}
/* ===================================================================== */
int main(INT32 argc, CHAR** argv)
{
    PIN_Init(argc, argv);
    // 注册子进程刚创建时要执行的FollowChild函数
    PIN_AddFollowChildProcessFunction(FollowChild, 0);
    // 开始执行，不返回
    PIN_StartProgram();
    return 0;
}</code></pre>


<h3 id="15-forkfork"><strong><em>15. 在fork前和fork后插桩</em></strong></h3>
<p>功能：使用<code>PIN_AddForkFunction()</code>和<code>PIN_AddForkFunctionProbed()</code>回调函数来在以下的FPOINT处执行自定义函数：</p>
<pre class="codehilite"><code>FPOINT_BEFORE       Call-back in parent, just before fork.
FPOINT_AFTER_IN_PARENT  Call-back in parent, immediately after fork.
FPOINT_AFTER_IN_CHILD   Call-back in child, immediately after fork.</code></pre>


<p><code>PIN_AddForkFunction()</code>工作在JIT模式下，<code>PIN_AddForkFunctionProbed()</code>工作在Probe模式下。</p>
<p>执行和查看输出：</p>
<pre class="codehilite"><code>$ make fork_jit_tool.test</code></pre>


<p><img alt="" src="./Pin 学习参考手册( See Bug 出品)_files/bbf086a5-e32a-494b-9a83-7b5bba381d87.jpg-w331s"></p>
<p>源码<code>source/tools/ManualExamples/fork_jit_tool.cpp</code>：</p>
<pre class="codehilite"><code>#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include "pin.H"
#include &lt;iostream&gt;
#include &lt;fstream&gt;
using std::cerr;
using std::endl;
INT32 Usage()
{
    cerr &lt;&lt; "This pin tool registers callbacks around fork().\n"
            "\n";
    cerr &lt;&lt; KNOB_BASE::StringKnobSummary();
    cerr &lt;&lt; endl;
    return -1;
}
pid_t parent_pid;
PIN_LOCK pinLock;
VOID BeforeFork(THREADID threadid, const CONTEXT* ctxt, VOID* arg)
{
    PIN_GetLock(&amp;pinLock, threadid + 1);
    cerr &lt;&lt; "TOOL: Before fork." &lt;&lt; endl;
    PIN_ReleaseLock(&amp;pinLock);
    parent_pid = PIN_GetPid();
}
VOID AfterForkInParent(THREADID threadid, const CONTEXT* ctxt, VOID* arg)
{
    PIN_GetLock(&amp;pinLock, threadid + 1);
    cerr &lt;&lt; "TOOL: After fork in parent." &lt;&lt; endl;
    PIN_ReleaseLock(&amp;pinLock);
    if (PIN_GetPid() != parent_pid)
    {
        cerr &lt;&lt; "PIN_GetPid() fails in parent process" &lt;&lt; endl;
        exit(-1);
    }
}
VOID AfterForkInChild(THREADID threadid, const CONTEXT* ctxt, VOID* arg)
{
    PIN_GetLock(&amp;pinLock, threadid + 1);
    cerr &lt;&lt; "TOOL: After fork in child." &lt;&lt; endl;
    PIN_ReleaseLock(&amp;pinLock);
    if ((PIN_GetPid() == parent_pid) || (getppid() != parent_pid))
    {
        cerr &lt;&lt; "PIN_GetPid() fails in child process" &lt;&lt; endl;
        exit(-1);
    }
}
int main(INT32 argc, CHAR** argv)
{
    PIN_InitSymbols();
    if (PIN_Init(argc, argv))
    {
        return Usage();
    }
    // Initialize the pin lock
    PIN_InitLock(&amp;pinLock);
    // Register a notification handler that is called when the application
    // forks a new process.
    PIN_AddForkFunction(FPOINT_BEFORE, BeforeFork, 0);
    PIN_AddForkFunction(FPOINT_AFTER_IN_PARENT, AfterForkInParent, 0);
    PIN_AddForkFunction(FPOINT_AFTER_IN_CHILD, AfterForkInChild, 0);
    // Never returns
    PIN_StartProgram();
    return 0;
}</code></pre>


<h2 id="4_2"><strong><em>4. 回调</em></strong></h2>
<p>这部分主要介绍几个Pin的用于注册回调函数的API：</p>
<ul>
<li>
<p><a href="https://software.intel.com/sites/landingpage/pintool/docs/98437/Pin/html/group__INS__INSTRUMENTATION.html#ga1333734dbf7d552365a24cd945d5691d">INS_AddInstrumentFunction</a> (INSCALLBACK fun, VOID *val)：注册以指令粒度插桩的函数</p>
</li>
<li>
<p><a href="https://software.intel.com/sites/landingpage/pintool/docs/98437/Pin/html/group__TRACE.html#gab2f19ff0a9198c83715eea79ada22503">TRACE_AddInstrumentFunction</a> (TRACECALLBACK fun, VOID *val)：注册以trace粒度插桩的函数</p>
</li>
<li>
<p><a href="https://software.intel.com/sites/landingpage/pintool/docs/98437/Pin/html/group__RTN.html#ga63bd82d1e10ee8c83d67529845f5ca46">RTN_AddInstrumentFunction</a> (RTNCALLBACK fun, VOID *val)：注册以routine粒度插桩的函数</p>
</li>
<li>
<p><a href="https://software.intel.com/sites/landingpage/pintool/docs/98437/Pin/html/group__IMG.html#ga4a067152140ead3e23279ab2bd6cd723">IMG_AddInstrumentFunction</a> (IMGCALLBACK fun, VOID *val)：注册以image粒度插桩的函数</p>
</li>
<li>
<p><a href="https://software.intel.com/sites/landingpage/pintool/docs/98437/Pin/html/group__PIN__CONTROL.html#gaa78c7b560975a6feffa420fadedc0627">PIN_AddFiniFunction</a> (FINICALLBACK fun, VOID *val)：注册在应用程序退出前执行的函数，该类函数不进行插桩，可以有多个。</p>
</li>
<li>
<p><a href="https://software.intel.com/sites/landingpage/pintool/docs/98437/Pin/html/group__PIN__CONTROL.html#ga7501b4226bc92f358b7b361eea0929d2">PIN_AddDetachFunction</a> (DETACHCALLBACK fun, VOID *val)：注册在Pin通过<code>PIN_Detach()</code>函数放弃对应用程序的控制权限之前执行的函数，一个进程只调用一次，可以被任何线程调用，此时Pin的内存并没有释放。</p>
</li>
</ul>
<p>对于每个注册函数的第二个参数val将在“回调”时传递给回调函数。如果在实际的场景中不需要传递第二个参数，为了保证安全，可以传递将val的值设置为0进行传递。val的理想使用方式是传递一个指向类实例的指针，这样回调函数在取消引用该指针前需要将其转换回一个对象。</p>
<p>所有的注册函数都会返回一个PIN_CALLBACK对象，该对象可以在后续过程中用于操作注册的回调的相关属性。</p>
<h3 id="pinapi"><strong><em>PIN回调操作相关API</em></strong></h3>
<p>在注册函数返回PIN_CALLBACK对象后，可以使用PIN_CALLBACKAPI对其进行操作，来检索和修改在Pin中已注册的回调函数的属性。</p>
<p>声明：</p>
<pre class="codehilite"><code>typedef COMPLEX_CALLBACKVAL_BASE * PIN_CALLBACK</code></pre>


<p>函数：</p>
<ol>
<li>CALLBACK_GetExecutionOrder()</li>
</ol>
<p>声明：</p>
<pre class="codehilite"><code>VOID   CALLBACK_GetExecutionOrder (PIN_CALLBACK callback)</code></pre>


<p>作用：获取已注册回调函数的执行顺序。越靠前，越早被执行。</p>
<p>参数：callback，从<em>_Add</em>Funcxtion()函数返回的注册的回调函数</p>
<ol>
<li>CALLBACK_SetExecutionOrder()</li>
</ol>
<p>声明：</p>
<p><code>VOID  CALLBACK_SetExecutionOrder (PIN_CALLBACK callback, CALL_ORDER order)</code></p>
<p>作用：设置已注册回调函数的执行顺序。越靠前，越早被执行。</p>
<p>参数：callback，从<em>_Add</em>Funcxtion()函数返回的注册的回调函数；order，新设置的回调函数的执行顺序。</p>
<ol>
<li>PIN_CALLBACK_INVALID()</li>
</ol>
<p>声明：</p>
<p><code>const PIN_CALLBACK PIN_CALLBACK_INVALID(0)</code></p>
<p>PIN回调的无效值。</p>
<h3 id="call_order"><strong><em>CALL_ORDER</em></strong></h3>
<p><code>CALL_ORDER</code>是一个枚举类型，预定义了<code>IARG_CALL_ORDER</code>的值。其作用就是当指令有多个分析函数调用时，控制每个分析函数的调用顺序，默认值为<code>CALL_ORDER_DEFAULT</code>。</p>
<ul>
<li>
<p>CALL_ORDER_FIRST：首先执行该调用，整数值为100.</p>
</li>
<li>
<p>CALL_ORDER_DEFAULT：未指定<code>IARG_CALL_ORDER</code>时的默认值，整数值为200.</p>
</li>
<li>
<p>CALL_ORDER_LAST：最后执行该调用，整数值为300.</p>
</li>
</ul>
<p>在进行数值设定时，可以使用类似<code>CALL_ORDER_DEFAULT + 5</code>的格式来设置。</p>
<p>针对在相同插桩回调环境中的针对同一指令的、具备同样<code>CALL_ORDER</code>的多个分析调用，Pin会按照插入的顺序进行调用。</p>
<h2 id="5"><strong><em>5. 修改程序指令</em></strong></h2>
<p>虽然Pin的主要用途是对二进制程序进行插桩，但是它也可以实现对程序指令的修改。</p>
<h3 id="51"><strong><em>5.1 实现方式</em></strong></h3>
<p>最简单的实现方式是插入一个分析routine来模拟指令执行，然后调用INS_Delete()来删除指令。也可以通过直接或间接插入程序执行流分支（使用<code>INS_InsertDirectJump</code>和<code>INS_InsertIndirectJump</code>）实现，这种方式会改变程序的执行流，但是会更容易实现指令模拟。</p>
<h4 id="ins_insertdirectjump"><strong><em>INS_InsertDirectJump()</em></strong></h4>
<p>声明：</p>
<p><code>VOID INS_InsertDirectJump(INS ins, IPOINT ipoint, ADDRINT tgt)</code></p>
<p>参数：</p>
<ul>
<li>
<p>ins：输入的指令</p>
</li>
<li>
<p>ipoint：与ins相关的location（仅支持IPOINT_BEFORE和IPOINT_AFTER）</p>
</li>
<li>
<p>tgt：target的绝对地址</p>
</li>
</ul>
<p>作用：插入相对于给定指令的直接跳转指令，与INS_Delete()配合使用可以模拟控制流转移指令。</p>
<h4 id="ins_insertindirectjump"><strong><em>INS_InsertIndirectJump()</em></strong></h4>
<p>声明：</p>
<pre class="codehilite"><code>VOID INS_InsertIndirectJump (   INS     ins, IPOINT     ipoint, REG     reg)</code></pre>


<p>参数：</p>
<ul>
<li>
<p>ins：输入的指令</p>
</li>
<li>
<p>ipoint：与ins相关的location（仅支持IPOINT_BEFORE和IPOINT_AFTER</p>
</li>
<li>
<p>reg：target的寄存器</p>
</li>
</ul>
<p>作用：插入相对于给定指令的间接跳转指令，与INS_Delete()配合使用可以模拟控制流转移指令。</p>
<h3 id="52"><strong><em>5.2 指令内存修改</em></strong></h3>
<p>对于原始指令使用到的内存的访问，可以通过使用INS_RewriteMemoryOperand来引用通过分析routine计算得到的值来替代。</p>
<p>需要注意的是，对于指令的修改操作，会在所有的指令插桩操作完成后进行，因此在进行指令插桩时，插桩routine看到的都是原始的、没有经过修改的程序指令。</p>
<h4 id="ins_rewritememoryoperand"><strong><em>INS_RewriteMemoryOperand()</em></strong></h4>
<p>声明：</p>
<pre class="codehilite"><code>VOID INS_RewriteMemoryOperand(INS ins, UINt32 memindex, REG newBase)</code></pre>


<p>参数：</p>
<ul>
<li>
<p>ins：输入指令</p>
</li>
<li>
<p>memindex：控制需要重写的内存操作数（0，1，...）</p>
</li>
<li>
<p>newBase：包含新操作数地址的寄存器，通常是通过PIN_ClainToolRegister分配的临时寄存器</p>
</li>
</ul>
<p>作用：更改此内存访问指令以饮用包含在给定特定寄存器中的虚拟内存地址。</p>
<p>在IA-32和Intel 64平台上，修改后的操作数仅使用具有新基址寄存器newBase的基址寄存器进行寻址。原始指令中该操作数的任何index， scale或者offset filed都会被删除。</p>
<p>该函数可以用于重写内存操作数，包括隐式的（如call、ret、push、pop），唯一不能重写的指令是第二个操作数大于0的enter。</p>
<p>newBase中的地址是中是该操作数将访问的最低地址，如果操作数在内存访问之前被指令修改，如push，则newBase中的值将不是堆栈指针，而是指令访问的内存地址。</p>
<p>用于内存地址重写的一个样例插桩代码如下：</p>
<pre class="codehilite"><code>// 映射originalEa到一个翻译后的地址
static ADDRINT ProcessAddress(ADDRINT originalEa, ADDRINT size, UINT32 access);
...
   for (UINT32 op = 0; op&lt;INS_MemoryOperandCount(ins); op++) // 首先遍历内存操作指令进行计数
   {
       UINT32 access = (INS_MemoryOperandIsRead(ins,op)    ? 1 : 0) |  // 判断是内存读还是内存写
                       (INS_MemoryOperandIsWritten(ins,op) ? 2 : 0);
       INS_InsertCall(ins, IPOINT_BEFORE,
                      AFUNPTR(ProcessAddress),
                      IARG_MEMORYOP_EA,   op,
                      IARG_MEMORYOP_SIZE, op,
                      IARG_UINT32,        access,
                      IARG_RETURN_REGS,   REG_INST_G0+i,
                      IARG_END);  // 在指令处进行插桩
       INS_RewriteMemoryOperand(ins, i, REG(REG_INST_G0+i));  // 重写内存指令的操作数
   }</code></pre>


<h2 id="6-pintool"><strong><em>6. 应用Pintool</em></strong></h2>
<p>命令行：</p>
<pre class="codehilite"><code>pin [pin-option]... -t [toolname] [tool-options]... -- [application] [application-option]..</code></pre>


<h3 id="61-pin"><strong><em>6.1 Pin命令行选项</em></strong></h3>
<p>如下是Pin的命令行的完整option列表：</p>
<table>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>-follow_execv</td>
<td>使用Pin执行由execv类系统调用产生的所有进程</td>
</tr>
<tr>
<td>-help</td>
<td>帮助信息</td>
</tr>
<tr>
<td>-pause_tool</td>
<td>暂停并打印PID以可以在tool加载后attach到debugger，处理过程在‘n’秒后重启</td>
</tr>
<tr>
<td>-logfile</td>
<td>指定log文件的名字和路径，默认路径为当前工作目录，默认文件名为pin.log</td>
</tr>
<tr>
<td>-unique_logfile</td>
<td>添加pid到log文件名中</td>
</tr>
<tr>
<td>-error_file</td>
<td>指定error文件的名字和路径，默认路径为当前工作目录。如果设置了error文件，则所有error都会写入到文件中，并且不会在console中显示。如果没有指定，则不创建文件。</td>
</tr>
<tr>
<td>-unique_error_file</td>
<td>添加pid到error文件名中</td>
</tr>
<tr>
<td>-injection</td>
<td>的选项为dynamic， self， child， parent，只能在UNIX中使用，详看<a href="https://software.intel.com/sites/landingpage/pintool/docs/98437/Pin/html/index.html#INJECTION">Injection</a>，默认使用dynamic。</td>
</tr>
<tr>
<td>-inline</td>
<td>内联简单的分析routine</td>
</tr>
<tr>
<td>-log_inline</td>
<td>在pin.log文件中记录哪些分析routine被设置成了内联</td>
</tr>
<tr>
<td>-cc_memory_size</td>
<td>最大代码缓存，字节为单位。0为默认值，表示不做限制。必须设置为代码缓存块大小的对齐倍数。</td>
</tr>
<tr>
<td>-pid <pid #=""></pid></td>
<td>使用Pin和Pintool attach一个正在运行的进程</td>
</tr>
<tr>
<td>-pin_memory_range</td>
<td>限制Pin到一个内存范围内，0x80000000:0x90000000 or size: 0:0x10000000.</td>
</tr>
<tr>
<td>-restric_memory</td>
<td>阻止Pin的动态加载器使用该地址范围：0x10000000:0x20000000</td>
</tr>
<tr>
<td>-pin_memory_size</td>
<td>限制Pin和Pintool可以动态分配的字节数。Pin分配的字节数定义为Pin分配的内存页数乘以页大小。</td>
</tr>
<tr>
<td>-tool_load_option</td>
<td>加载有附加标志的tool。</td>
</tr>
<tr>
<td>-t</td>
<td>指定加载的Pintool。</td>
</tr>
<tr>
<td>-t64 &lt;64-bit toolname&gt;</td>
<td>指定针对Intel 64架构的64-bit的Pintool。</td>
</tr>
<tr>
<td>-p32</td>
<td>指定IA-32架构下的Pintool</td>
</tr>
<tr>
<td>-p64</td>
<td>指定针对Intel 64架构的Pintool</td>
</tr>
<tr>
<td>-smc-support</td>
<td>是否开启app的SMC功能，1开启，0关闭。默认开启</td>
</tr>
<tr>
<td>-smc_strict</td>
<td>是否开启基本块内部的SMC，1开始，0关闭。默认关闭</td>
</tr>
<tr>
<td>-appdebug</td>
<td>调试目标程序，程序运行后立即在debugger中断下</td>
</tr>
<tr>
<td>-appdebug_enable</td>
<td>开启目标程序调试功能，但是在程序运行后不暂停</td>
</tr>
<tr>
<td>-appdebug_silent</td>
<td>当程序调试功能开启时，Pin打印消息告知如何连接外部debugger。但是在-appdebug_connection选项开启时不打印。</td>
</tr>
<tr>
<td>-appdebug_exclude</td>
<td>当程序调试功能开启，并指定了-follw_execv时，默认在所有子进程上启用调试。</td>
</tr>
<tr>
<td>-appdebug_allow_remote</td>
<td>允许debugger与Pin不运行在同一系统上，而是以远程方式进行连接。指定 -appdebug_connection 时会忽略该选项的值，因为 -appdebug_connection 明确指定了运行debugger的machine。</td>
</tr>
<tr>
<td>-appdebug_connection</td>
<td>当程序开启调试时，Pin默认会开启一个TCP端口等待debugger的连接。在开启该选项时，会在debugger中开启一个TCP端口来等待Pin的连接，相当于反置了默认的机制。该选项的格式为"[ip]:port"，“ip”以点十进制格式表达，如果省略了ip，则会连接本地的端口，端口号为十进制表示。需要注意的是，debugger为GDB时，不使用该选项。</td>
</tr>
<tr>
<td>-detach_reattach</td>
<td>允许在probe模式下进行detach和reattach，仅在Windows平台下使用。</td>
</tr>
<tr>
<td>-debug_instrumented_processes</td>
<td>允许debugger对经过插桩的进程进行attach，仅在Windows平台下使用。</td>
</tr>
<tr>
<td>-show_asserts</td>
<td>健全性检查</td>
</tr>
</tbody>
</table>
<p>此外，还支持如下的tool options，它们需要跟在tool名字后面，但是要在--符号前：</p>
<table>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>-logifle</td>
<td>指定log文件的名字和路径，默认路径为当前工作目录，默认文件名为pintool.log</td>
</tr>
<tr>
<td>-unique_logfile</td>
<td>添加pid到log文件名中</td>
</tr>
<tr>
<td>-discard_line_info <module_name></module_name></td>
<td>忽略特定模块的信息，模块名应该为没有路径的短文件名，不能是符号链接</td>
</tr>
<tr>
<td>-discard_line_info_all</td>
<td>忽略所有模块的信息</td>
</tr>
<tr>
<td>-help</td>
<td>帮助信息</td>
</tr>
<tr>
<td>-support_jit_api</td>
<td>启用托管平台支持</td>
</tr>
<tr>
<td>-short_name</td>
<td>使用最短的RTN名称。</td>
</tr>
<tr>
<td>-symbol_path</td>
<td>指定用分号分隔的路径列表，用于搜索以查找符号和行信息。仅在Windows平台下使用。</td>
</tr>
<tr>
<td>-slow_asserts</td>
<td>健全性检查</td>
</tr>
</tbody>
</table>
<h3 id="62-intelr-64"><strong><em>6.2 在Intel(R) 64架构插桩</em></strong></h3>
<p>IA-32和Intel(R) 64架构的Pin kit是一个组合kit，均包含32-bit和64-bit的版本。这就为复杂的环境提供了极高的可运行性，例如一个稍微有点复杂的运行如下：</p>
<pre class="codehilite"><code>pin [pin-option]... -t64 &lt;64-bit toolname&gt; -t &lt;32-bit toolname&gt; [tool-options]...
-- &lt;application&gt; [application-option]..</code></pre>


<p>需要注意的是：</p>
<ul>
<li>
<p>t64选项需要用在-t选项的前面</p>
</li>
<li>
<p>当-t64和-t一起使用时，-t后面跟的时32-bit的tool。不推荐使用不带-t的-t64，因为在这种情况下，当给定32-bit应用程序时，Pin将在不应用任何工具的情况下运行该应用程序。</p>
</li>
<li>
<p>[tool-option]会同时作用于64-bit和32-bit的tool，并且必须在-t &lt;32-bit toolname&gt;后面进行指定。</p>
</li>
</ul>
<h3 id="63"><strong><em>6.3 注入</em></strong></h3>
<p>选项-injection仅在UNIX平台下可以使用，该选项控制着Pin注入到目标程序进程的方式。</p>
<p>默认情况下，建议使用dynamic模式。在该模式下，使用的是对父进程注入的方式，除非是系统内核不支持。子进程注入方式会创建一个pin的子进程，所以会看到pin进程和目标程序进程同时运行。使用父进程注入方式时，pin进程会在注入完成后退出，所以相对来说比较稳定。在不支持的平台上使用父进程注入方式可能出现意料之外的问题。</p>
<h2 id="7-pintool"><strong><em>7. 编写Pintool</em></strong></h2>
<h3 id="71-pintool"><strong><em>7.1 记录Pintool的消息</em></strong></h3>
<p>Pin提供了将Pintool的messages写入到文件的机制——LOG() api，在合适的获取message的位置使用即可。默认的文件名为pintool.log，存储路径为当前工作目录，可以使用-logfile选项来改变log文件的路径和名字。</p>
<pre class="codehilite"><code>LOG( "Replacing function in " + IMG_Name(img) + "\n" );
LOG( "Address = " + hexstr( RTN_Address(rtn)) + "\n" );
LOG( "Image ID = " + decstr( IMG_Id(img) ) + "\n" );</code></pre>


<h3 id="72-pintool"><strong><em>7.2 编写Pintool时的性能考量</em></strong></h3>
<p>Pintool的开发质量会很大程度上决定tool的性能如何，例如在进行插桩时的速度问题。将通过一个例子来介绍一些提高tool性能的技巧。</p>
<p>首先是插桩部分代码：</p>
<pre class="codehilite"><code>VOID Instruction(INS ins, void *v)
{
   ...
   if ( [ins is a branch **or** a call instruction] )
   {
    INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR) docount2,
            IARG_INST_PTR,
            IARG_BRANCH_TARGET_ADDR,
            IARG_BRANCH_TAKEN,
            IARG_END);
   }
   ...
}</code></pre>


<p>然后是分析代码：</p>
<pre class="codehilite"><code>VOID docount2( ADDRINT src, ADDRINT dst, INT32 taken )
{
  if(!taken) return;
  COUNTER *pedg = Lookup( src,dst );
  pedg-&gt;_count++;
}</code></pre>


<p>该工具的目的是计算控制流图中每个控制流变化的边界被遍历的频率。工作原理如下：插桩组件通过调用docount2对每个分支进行插桩。传入的参数为源分支和目标分支以及分支是否被执行。源分支和目标分支代表来控制流边界的源和目的。如果没有执行分支，控制流不会发生改变，因此分析routine会立即返回。如果执行了分支，就使用src和dst参数来查找与此边界相关的计数器，并增加计数器的值。</p>
<p><strong><em>Shifting Computation for Analysis to Instrumentation Code</em></strong></p>
<p>在一个典型的应用程序中，大概每5条指令构成一个分支，在这些指令执行时会调用<code>Lookup</code>函数，造成性能下降。我们思考这个过程可以发现，在指令执行时，每条指令只会调用一次插桩代码，但会多次调用分析代码。所以，可以想办法将计算工作从分析代码转移到插桩代码，这样就可以降低调用次数，从而提升性能。</p>
<p>首先，就大多数分支而言，我们可以在<code>Instruction()</code>中找到目标分支。对于这些分支，我们可以在Instruction()内部调用<code>Lookup()</code>而不是<code>docount2()</code>，对于相对较少的间接分支，我们仍然需要使用原来的方法。</p>
<p>因此，我们增加一个新的函数<code>docount</code>，原来的<code>docount2</code>函数保持不变：</p>
<pre class="codehilite"><code>VOID docount( COUNTER *pedg, INT32 taken )
{
  if( !taken ) return;
  pedg-&gt;_count++;
}</code></pre>


<p>相应地，修改插桩函数：</p>
<pre class="codehilite"><code>VOID Instruction(INS ins, void *v)
{
   ...
  if (INS_IsDirectControlFlow(ins))
  {
    COUNTER *pedg = Lookup( INS_Address(ins), INS_DirectControlFlowTargetAddress(ins) );
    INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR) docount,
            IARG_ADDRINT, pedg,
            IARG_BRANCH_TAKEN,
            IARG_END);
  }
  else
  {
    INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR) docount2,
            IARG_INST_PTR,
            IARG_BRANCH_TARGET_ADDR,
            IARG_BRANCH_TAKEN,
            IARG_END);
  }
   ...
}</code></pre>


<p>在插桩函数内部根据不同的情况，执行不同的分析代码，避免对所有类型的指令都笼统地调用性能要求高<code>docount2</code>函数。</p>
<p>最终实现的完整代码如下：</p>
<pre class="codehilite"><code>/* ===================================================================== */

/*!
  对于已经进行过插桩的Edge，重用entry；否则创建一个新的。
 */

static COUNTER* Lookup(EDGE edge) // 查找边界
{
    COUNTER*&amp; ref = EdgeSet[edge];

    if (ref == 0)
    {
        ref = new COUNTER();
    }

    return ref;
}

/* ===================================================================== */
// 分析routine代码

VOID docount(COUNTER* pedg) { pedg-&gt;_count++; }

/* ===================================================================== */
// 对于间接控制流，我们不知道边界，所以需要进行查找。

VOID docount2(ADDRINT src, ADDRINT dst, ADDRINT n, ETYPE type, INT32 taken)
{
    if (!taken) return;
    COUNTER* pedg = Lookup(EDGE(src, dst, n, type));
    pedg-&gt;_count++;
}

/* ===================================================================== */

VOID Instruction(INS ins, void* v) // 插桩函数
{
    if (INS_IsDirectControlFlow(ins)) // 如果是直接控制流（ins为控制流指令，目标地址由指令指针或立即数指定）
    {
        ETYPE type = INS_IsCall(ins) ? ETYPE_CALL : ETYPE_BRANCH; // 判断是否为call指令，是则返回ETYPE_CALL

        // 静态目标可以在这里进行一次映射
        // 参数分别为当前指令地址、当前指令目标地址、下一指令地址、指令类型
        COUNTER* pedg = Lookup(EDGE(INS_Address(ins), INS_DirectControlFlowTargetAddress(ins), INS_NextAddress(ins), type)); 
        // 插桩
        INS_InsertCall(ins, IPOINT_TAKEN_BRANCH, (AFUNPTR)docount, IARG_ADDRINT, pedg, IARG_END);
    }
    else if (INS_IsIndirectControlFlow(ins)) // 如果是间接控制流（ins为控制流指令，且目标地址通过内存或寄存器提供）
    {
        ETYPE type = ETYPE_IBRANCH; // 直接指定类型为间接控制流

        if (INS_IsRet(ins)) // 是否为ret或iret
        {
            type = ETYPE_RETURN;
        }
        else if (INS_IsCall(ins))
        {
            type = ETYPE_ICALL;
        }
        // 进行插桩
        INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)docount2, IARG_INST_PTR, IARG_BRANCH_TARGET_ADDR, IARG_ADDRINT, INS_NextAddress(ins), IARG_UINT32, type, IARG_BRANCH_TAKEN, IARG_END);
    }
    else if (INS_IsSyscall(ins))  //  如果是syscall指令
    {
        COUNTER* pedg = Lookup(EDGE(INS_Address(ins), ADDRINT(~0), INS_NextAddress(ins), ETYPE_SYSCALL));
        INS_InsertPredicatedCall(ins, IPOINT_BEFORE, (AFUNPTR)docount, IARG_ADDRINT, pedg, IARG_END);
    }
}

/* ===================================================================== */

inline INT32 AddressHighNibble(ADDRINT addr) { return 0xf &amp; (addr &gt;&gt; (sizeof(ADDRINT) * 8 - 4)); }

/* ===================================================================== */
static std::ofstream* out = 0;

VOID Fini(int n, void* v) // 程序结束时的处理函数
{
    const INT32 nibble = KnobFilterByHighNibble.Value();

    *out &lt;&lt; "EDGCOUNT        4.0         0\n"; // profile header, no md5sum
    UINT32 count = 0;

    for (EDG_HASH_SET::const_iterator it = EdgeSet.begin(); it != EdgeSet.end(); it++)
    {
        const pair&lt; EDGE, COUNTER* &gt; tuple = *it;
        // skip inter shared lib edges

        if (nibble &gt;= 0 &amp;&amp; nibble != AddressHighNibble(tuple.first._dst) &amp;&amp; nibble != AddressHighNibble(tuple.first._src))
        {
            continue;
        }

        if (tuple.second-&gt;_count == 0) continue;

        count++;
    }

    *out &lt;&lt; "EDGs " &lt;&lt; count &lt;&lt; endl;
    *out &lt;&lt; "# src          dst        type    count     next-ins\n";
    *out &lt;&lt; "DATA:START" &lt;&lt; endl;

    for (EDG_HASH_SET::const_iterator it = EdgeSet.begin(); it != EdgeSet.end(); it++)
    {
        const pair&lt; EDGE, COUNTER* &gt; tuple = *it;

        // skip inter shared lib edges

        if (nibble &gt;= 0 &amp;&amp; nibble != AddressHighNibble(tuple.first._dst) &amp;&amp; nibble != AddressHighNibble(tuple.first._src))
        {
            continue;
        }

        if (tuple.second-&gt;_count == 0) continue;

        *out &lt;&lt; StringFromAddrint(tuple.first._src) &lt;&lt; " " &lt;&lt; StringFromAddrint(tuple.first._dst) &lt;&lt; " "
             &lt;&lt; StringFromEtype(tuple.first._type) &lt;&lt; " " &lt;&lt; decstr(tuple.second-&gt;_count, 12) &lt;&lt; " "
             &lt;&lt; StringFromAddrint(tuple.first._next_ins) &lt;&lt; endl;
    }

    *out &lt;&lt; "DATA:END" &lt;&lt; endl;
    *out &lt;&lt; "## eof\n";
    out-&gt;close();
}

/* ===================================================================== */
/* Main                                                                  */
/* ===================================================================== */

int main(int argc, char* argv[])
{
    if (PIN_Init(argc, argv)) // 初始化
    {
        return Usage();
    }

    string filename = KnobOutputFile.Value(); // 输出文件
    if (KnobPid)
    {
        filename += "." + decstr(getpid());
    }
    out = new std::ofstream(filename.c_str());

    INS_AddInstrumentFunction(Instruction, 0); // 注册插桩函数
    PIN_AddFiniFunction(Fini, 0); // 注册Fini函数

    // 开始执行，不返回

    PIN_StartProgram();

    return 0;
}

/* ===================================================================== */
/* eof */
/* ===================================================================== */</code></pre>


<h3 id="73"><strong><em>7.3 消除控制流</em></strong></h3>
<p>上面新增的<code>docunt()</code>函数的代码十分简洁，极大地提升了性能。除此之外，还可以被Pin内联，进一步避免函数调用的开销。</p>
<p>但是现在的<code>docount()</code>函数中存在控制流，这有可能在进行内联时发生未知的改变。最好的解决办法是去掉函数中的控制流，这样进行内联时可以保证健壮性。</p>
<p>考虑到<code>docount()</code>函数的'taken'参数要么为0，要么为1，所以可以将函数代码修改为如下：</p>
<pre class="codehilite"><code>VOID docount( COUNTER *pedg, INT32 taken )
{
  pedg-&gt;_count += taken;
}</code></pre>


<p>如此修改后，<code>docunt()</code>函数就可以进行内联了，并且可以保证函数的健壮性。</p>
<h3 id="74-pin"><strong><em>7.4 让Pin决定插桩位置</em></strong></h3>
<p>在某些情况下，我们不关心具体在什么位置进行插桩，只要保证插桩代码位于基本块内部即可。在这种情况下，我们可以将插桩位置的选择权交给Pin自身，Pin可以选择需要最少寄存器进行保存和恢复的插入点，提升性能。</p>
<p>一个样例如下：</p>
<pre class="codehilite"><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include "pin.H"
using std::cerr;
using std::endl;
using std::ios;
using std::ofstream;
using std::string;

ofstream OutFile;

// 记录运行的指令的数量，设置为静态变量方便编译器优化docount函数
static UINT64 icount = 0;

// 在每个块之前调用该函数
// 对calls使用fast linkage
VOID PIN_FAST_ANALYSIS_CALL docount(ADDRINT c) { icount += c; }

// Pin在遇到一个新块时调用，插入对docount 函数的调用
VOID Trace(TRACE trace, VOID* v)
{
    // 检查trace中的每个基本块
    for (BBL bbl = TRACE_BblHead(trace); BBL_Valid(bbl); bbl = BBL_Next(bbl))
    {

        // 对每个bbl插入对docount函数的调用，将指令数量作为参数传递
        // IPOINT_ANYWHERE参数允许Pin在bbl内部任意位置插入call以获取最好的性能
        // 对call使用fast linkage
        BBL_InsertCall(bbl, IPOINT_ANYWHERE, AFUNPTR(docount), IARG_FAST_ANALYSIS_CALL, IARG_UINT32, BBL_NumIns(bbl), IARG_END);
    }
}

KNOB&lt; string &gt; KnobOutputFile(KNOB_MODE_WRITEONCE, "pintool", "o", "inscount.out", "specify output file name");

// 程序退出时调用
VOID Fini(INT32 code, VOID* v)
{
    OutFile.setf(ios::showbase);
    OutFile &lt;&lt; "Count " &lt;&lt; icount &lt;&lt; endl;
    OutFile.close();
}

/* ===================================================================== */
/* Print Help Message                                                    */
/* ===================================================================== */

INT32 Usage()
{
    cerr &lt;&lt; "This tool counts the number of dynamic instructions executed" &lt;&lt; endl;
    cerr &lt;&lt; endl &lt;&lt; KNOB_BASE::StringKnobSummary() &lt;&lt; endl;
    return -1;
}

/* ===================================================================== */
/* Main                                                                  */
/* ===================================================================== */

int main(int argc, char* argv[])
{
    // 初始化Pin
    if (PIN_Init(argc, argv)) return Usage();

    OutFile.open(KnobOutputFile.Value().c_str());

    // 注册插桩函数Trace
    TRACE_AddInstrumentFunction(Trace, 0);

    // 注册Fini函数
    PIN_AddFiniFunction(Fini, 0);

    // 开始执行，不返回
    PIN_StartProgram();

    return 0;
}</code></pre>


<p>这里<code>IPOINT</code>是一个枚举类型，决定了分析call被插入到什么地方。插入的对象可以是：INS，BBL，TRACE，RTN，其完整可用的值如下：</p>
<ul>
<li>
<p>IPOINT_BEFORE：在插桩对象的第一条指令之前插入call，总是有效</p>
</li>
<li>
<p>IPOINT_AFTER：在插桩对象的最后一条指令的失败路径处插入call</p>
</li>
<li>如果是routine（RTN），在所有返回路径处插桩</li>
<li>如果是instruction（INS），仅在INS_IsValidForIpointAfter()函数为真的情况下适用</li>
<li>如果是BBL，仅在<code>BBL_HasFallThrough()</code>函数为真的情况下适用</li>
<li>
<p>如果是TRACE，仅在<code>TRACE_HasFallThrough()</code>函数为真的情况下适用</p>
</li>
<li>
<p>IPOINT_ANYWHERE：在插桩对象的任意位置插入call，不适用<code>INS_InsertCall()</code>和<code>INS_InsertThenCall()</code>函数</p>
</li>
<li>
<p>IPOINT_TAKEN_BRANCH：在插桩对象的控制流的执行边界处插入call，仅适用于<code>INS_IsValidForIpointTakenBranch()</code>返回真的情况。</p>
</li>
</ul>
<h3 id="75-fast-call-linkages"><strong><em>7.5 使用Fast Call Linkages</em></strong></h3>
<p>对于一些比较“小”的函数来说，对函数的调用开销有时与函数自身的运算开销基本相同，因此一些编译器会提供一些调用链接优化机制来降低开销。例如，IA-32下的gcc有一个在寄存器中传递参数的regparm属性。</p>
<p>Pin中有一定数量的备用链接，使用<code>PIN_FAST_ANALYSIS_CALL</code>来声明分析函数即可使用，而插桩函数<code>InsertCall</code>则需要使用<code>IARG_FAST_ANALYSIS_CALL</code>。如果二者只更改了一个，那么就可能出现传参错误。例如前面给出的源码例子就使用了fast call linkages：</p>
<pre class="codehilite"><code>... ...
// 对分析函数使用fast linkage*
VOID PIN_FAST_ANALYSIS_CALL docount(ADDRINT c) { icount += c; }

VOID Trace(TRACE trace, VOID* v)
{
  // 检查trace中的每个基本块*
  for (BBL bbl = TRACE_BblHead(trace); BBL_Valid(bbl); bbl = BBL_Next(bbl))
  {

  // 对插桩函数使用fast linkage*
BBL_InsertCall(bbl, IPOINT_ANYWHERE, AFUNPTR(docount), IARG_FAST_ANALYSIS_CALL, IARG_UINT32, BBL_NumIns(bbl), IARG_END);
  }
}
... ...</code></pre>


<p>在对比较复杂的大型函数使用该方法时，效果并不明显，但不会造成性能的下降。</p>
<p>第二个调用链接优化是消除帧指针。如果使用gcc，则推荐加上"-fomit-frame-pointer"选项。Pin官方的标准Pintool的makefile包括该选项。与<code>PIN_FAST_ANALYSIS_CALL</code>一样，该选项对“小”函数的效果比较明显。需要注意的是，debugger会根据帧指针来显示堆栈回溯情况，所以如果想调试Pintool的话，就不要设置该选项。如果使用标准的Pintool的makefile来进行变异，则可以通过修改<code>OPT</code>选项来进行改变：</p>
<pre class="codehilite"><code>make OPT=-O0</code></pre>


<h3 id="76-pin"><strong><em>7.6 重写有条件的分析例程实现Pin内联</em></strong></h3>
<p>Pin通过自动内联没有控制流变化的分析routine来提升插桩性能。但是有很多分析routine是有控制流的，最典型的就是有一个简单的“if-then”的条件语句，它只会执行少量的分析代码，并“then”部分只执行一次。为了将这类的语句转换为常规的没有控制流变化的语句，Pin提供了一些插桩API来重写分析routine。下面是一个重写的例子：</p>
<p>例如我们当前想要实现的一个分析routine的代码如下：</p>
<pre class="codehilite"><code>// IP-sampling分析routine实现:

VOID IpSample(VOID *ip)
{
    --icount;
    if (icount == 0)
    {
        fprintf(trace, "%p\n", ip);
        icount = N + rand() % M;
    }
}</code></pre>


<p>在原始的IpSample()函数中有一个明显的条件语句，会存在控制流的变化。如何消除该条件控制流的存在呢？</p>
<p>可以看到分析routine内部其实可以拆解为2部分功能：<code>icount</code>的自减和“if”语句，那么可以使用两个单独的函数实现。而且，前者比后者的执行频率要更高。拆解后的代码如下：</p>
<pre class="codehilite"><code>/*
 *  IP-sampling分析routine实现:
 *
 *        VOID IpSample(VOID *ip)
 *        {
 *            --icount;
 *            if (icount == 0)
 *            {
 *               fprintf(trace, "%p\n", ip);
 *               icount = N + rand() % M;
 *            }
 *        }
 */
// 计算icount
ADDRINT CountDown()
{
    --icount;
    return (icount == 0);
}
// 打印当前指令的IP并且icount被重置为N和N+M中的一个随机数
VOID PrintIp(VOID* ip)
{
    fprintf(trace, "%p\n", ip);
    // 准备下次计算
    icount = N + rand() % M;
}</code></pre>


<p>一个完整的实现消除控制流变化的代码如下：</p>
<pre class="codehilite"><code>/* source/tools/ManualExamples/isampling.cpp */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include "pin.H"
FILE* trace;
const INT32 N = 100000;
const INT32 M = 50000;
INT32 icount = N;
/*
 *  IP-sampling分析routine实现:
 *
 *        VOID IpSample(VOID *ip)
 *        {
 *            --icount;
 *            if (icount == 0)
 *            {
 *               fprintf(trace, "%p\n", ip);
 *               icount = N + rand() % M;
 *            }
 *        }
 */
// 计算icount
ADDRINT CountDown()
{
    --icount;
    return (icount == 0);
}
// 打印当前指令的IP并且icount被重置为N和N+M中的一个随机数
VOID PrintIp(VOID* ip)
{
    fprintf(trace, "%p\n", ip);
    // 准备下次计算
    icount = N + rand() % M;
}

VOID Instruction(INS ins, VOID* v)
{
    // 每条指令执行后都会调用CountDown()
    INS_InsertIfCall(ins, IPOINT_BEFORE, (AFUNPTR)CountDown, IARG_END);
    // 只有当CountDown返回非0值时才会调用PrintIp() 
    INS_InsertThenCall(ins, IPOINT_BEFORE, (AFUNPTR)PrintIp, IARG_INST_PTR, IARG_END);
}

VOID Fini(INT32 code, VOID* v)
{
    fprintf(trace, "#eof\n");
    fclose(trace);
}
/* ===================================================================== */
/* Print Help Message                                                    */
/* ===================================================================== */
INT32 Usage()
{
    PIN_ERROR("This Pintool samples the IPs of instruction executed\n" + KNOB_BASE::StringKnobSummary() + "\n");
    return -1;
}
/* ===================================================================== */
/* Main                                                                  */
/* ===================================================================== */
int main(int argc, char* argv[])
{
    trace = fopen("isampling.out", "w");
    if (PIN_Init(argc, argv)) return Usage();
    INS_AddInstrumentFunction(Instruction, 0);
    PIN_StartProgram();
    return 0;
}</code></pre>


<p>使用条件插桩API <code>INS_InsertIfCall()</code>和<code>INS_InsertThenCall()</code>来告诉Pin只有当<code>CountDown()</code>执行结果非0时，才执行<code>PrintIp()</code>。这样一来，<code>CountDown()</code>函数就可以内联在Pin中，对于没有内联的PrintIp()则只有在满足条件时才会执行一次。</p>
<p><code>INS_InsertThenCall()</code>插进去的函数只有在<code>INS_InsertIfCall()</code>插进去的函数返回非0值时才会执行。这个功能可以说是一个十分巧妙的功能。</p>
<h2 id="8-pintool"><strong><em>8. 构建自己的Pintool</em></strong></h2>
<p>在开发自己的Pintool时，可以copy一份example目录， 然后在<code>makefile.rules</code>文件中添加上自己的tool，可以以最简单的MyPinTool为模版。</p>
<h3 id="81"><strong><em>8.1 在套件目录树内进行构建</em></strong></h3>
<p>如果直接修改<code>MyPinTool</code>，并且没有特殊的编译需求，则直接使用默认配置就好。如果要新增tool或者需要指定特殊的构建标志，则需要修改<code>makeifile.rules</code>文件。</p>
<p>构建YourTool.so(源文件为YourTool.cpp)：</p>
<pre class="codehilite"><code>make obj-intel64/YourTool.so</code></pre>


<p>如果想编译成IA-32架构，则使用“obj-ia32”替换“obj-intel64”即可。</p>
<h3 id="82"><strong><em>8.2 在套件目录树外构建</em></strong></h3>
<p>copy文件夹<code>MyPinTool</code>到指定位置子，然后编辑<code>makefile.rules</code>文件。</p>
<pre class="codehilite"><code>make PIN_ROOT=&lt;path to Pin kit&gt; obj-intel64/YourTool.so</code></pre>


<p>要更改将创建工具的目录，可以从命令行覆盖 OBJDIR 变量：</p>
<pre class="codehilite"><code>make PIN_ROOT=&lt;path to Pin kit&gt; OBJDIR=&lt;path to output dir&gt; &lt;path to output dir&gt;/YourTool.so</code></pre>


<h2 id="9-pinmakefile"><strong><em>9. Pin的makefile</em></strong></h2>
<h3 id="91"><strong><em>9.1 配置目录</em></strong></h3>
<p>目录<code>source/tools/Config</code>中存放了make配置的基本文件，不要轻易修改这些文件，可以基于其中的模版文件进行更新。</p>
<p><img alt="" src="./Pin 学习参考手册( See Bug 出品)_files/ea251af6-463d-41af-8c7f-362db3e6e2bc.png-w331s"> </p>
<p>下面对其中的几个关键文件进行说明：</p>
<ul>
<li>
<p>makefile.config：在include链中第一个应该include的文件。它保存了用户可用的所有相关标识和变量的文档，此外还包括特定于OS的配置文件。</p>
</li>
<li>
<p>unix.vars：该文件包含makefile使用的一些架构变量和实用程序的Unix定义。</p>
</li>
<li>
<p>makefile.default.rules：该文件包含默认的make目标、测试用例和构建规则。</p>
</li>
</ul>
<h3 id="92"><strong><em>9.2 测试目录</em></strong></h3>
<p><code>source/tools</code>目录下的每个测试性质的目录中都包含makefile链中的两个文件：</p>
<p><img alt="" src="./Pin 学习参考手册( See Bug 出品)_files/045ae5b7-e9c4-4fc1-a5b2-27f56257e0d8.png-w331s"></p>
<ul>
<li>
<p>makefile：运行make时调用，不要修改。其中保存了makefile链的所有相关配置文件的包含指令，属于通用文件，在所有的测试目录中都是相同的。</p>
</li>
<li>
<p>makefile.rules：目录特定文件，不同测试目录，文件内容不同。它保存了当前目录的逻辑，应该在目录中构建和运行的所有工具、应用程序和测试等都在该文件中进行定义。</p>
</li>
</ul>
<h3 id="93-makefile"><strong><em>9.3 向makefile中添加测试、工具和应用</em></strong></h3>
<p>下面介绍如何通过makefile构建二进制程序并运行测试。以下描述的变量都在<code>makefile.rules</code>文件的"Test targets"部分进行描述：</p>
<ul>
<li>
<p>TOOL_ROOTS：定义工具名称，不带文件扩展名，具体的文件扩展名将由make自动添加，例如YourTools.so；</p>
</li>
<li>
<p>APP_ROOTS：定义应用程序，不带文件扩展名，具体的文件扩展名将由make自动添加，例如YourApp.exe；</p>
</li>
<li>
<p>TEST_ROOTS：定义测试，不要加.test后缀，make会自动添加，例如YourTest.test。</p>
</li>
</ul>
<h3 id="94"><strong><em>9.4 定义构建规则</em></strong></h3>
<p>默认使用的构建规则是<code>source/tools/Config/makefile.default.rules</code>，输入为单一的c/cpp文件，生成相同名字的二进制程序。如果输入为多个源文件，且需要自定义构建规则，可以在<code>make.rules</code>文件的"Build rules"部分的末尾添加。如下是规则例子：</p>
<p>构建单一源文件且不进行优化：</p>
<pre class="codehilite"><code># Build the intermediate object file.
$(OBJDIR)YourTool$(OBJ_SUFFIX): YourTool.cpp
  $(CXX) $(TOOL_CXXFLAGS_NOOPT) $(COMP_OBJ)$@ $&lt;

# Build the tool as a dll (shared object).
$(OBJDIR)YourTool$(PINTOOL_SUFFIX): $(OBJDIR)YourTool$(OBJ_SUFFIX)
  $(LINKER) $(TOOL_LDFLAGS_NOOPT) $(LINK_EXE)$@ $&lt; $(TOOL_LPATHS) $(TOOL_LIBS)</code></pre>


<p>构建多源文件且进行优化：</p>
<pre class="codehilite"><code># Build the intermediate object file.
$(OBJDIR)Source1$(OBJ_SUFFIX): Source1.cpp
  $(CXX) $(TOOL_CXXFLAGS) $(COMP_OBJ)$@ $&lt;

# Build the intermediate object file.
$(OBJDIR)Source2$(OBJ_SUFFIX): Source2.c Source2.h
  $(CC) $(TOOL_CXXFLAGS) $(COMP_OBJ)$@ $&lt;

# Build the tool as a dll (shared object).
$(OBJDIR)YourTool$(PINTOOL_SUFFIX): $(OBJDIR)Source1$(OBJ_SUFFIX) $(OBJDIR)Source2$(OBJ_SUFFIX) Source2.h
  $(LINKER) $(TOOL_LDFLAGS_NOOPT) $(LINK_EXE)$@ $(^**:**%.h**=**) $(TOOL_LPATHS) $(TOOL_LIBS)</code></pre>


<h3 id="95-makefilerules"><strong><em>9.5 在makefile.rules定义测试片段</em></strong></h3>
<p>在"Test recipes"部分自定义自己的测试需求，例如：</p>
<pre class="codehilite"><code>YourTest.test: $(OBJDIR)YourTool$(PINTOOL_SUFFIX) $(OBJDIR)YourApp$(EXE_SUFFIX)
  $(PIN) -t $&lt; -- $(OBJDIR)YourApp$(EXE_SUFFIX)</code></pre>


<h3 id="96"><strong><em>9.6 变量和标志</em></strong></h3>
<p>摘取<code>makefile.config</code>中几个重点的标志进行说明：</p>
<p><code>IN_ROOT</code>：在套件外构建工具时指定Pin套件的位置。</p>
<p><code>CC</code>: 指定工具的默认c编译器。</p>
<p><code>CXX</code>：指定工具的默认c++编译器。</p>
<p><code>APP_CC</code>：指定应用程序的默认 c 编译器。如果未定义，APP_CC 将与 CC 相同。</p>
<p><code>APP_CXX</code>：指定应用程序的默认 c++ 编译器。如果未定义，APP_CXX 将与 CXX 相同。</p>
<p><code>TARGET</code>：指定默认目标架构，例如交叉编译。</p>
<p><code>ICC</code>: 使用英特尔编译器构建工具时指定 ICC=1。</p>
<p><code>DEBUG</code>: 当指定 DEBUG=1 时，在构建工具和应用程序时会生成调试信息。此外，不会执行任何编译和/或链接优化。</p>
        
<hr>
<p><img src="./Pin 学习参考手册( See Bug 出品)_files/0e69b04c-e31f-4884-8091-24ec334fbd7e.jpeg" alt="Paper" style="width: 220px">
本文由 Seebug Paper 发布，如需转载请注明来源。本文地址：<a href="https://paper.seebug.org/1742/">https://paper.seebug.org/1742/</a></p>
            
    </section>

    <nav class="pagination" role="navigation" style="padding: 3rem;">
        
        <a class="newer-posts" href="https://paper.seebug.org/1740/"><span aria-hidden="true">←</span>
            “刷脸时代”你的脸就是我的脸 -- 人脸识别漏洞分析 (下）
        </a>

        
        
        <a class="older-posts" href="https://paper.seebug.org/1741/">新型网络犯罪攻防技术研究 <span aria-hidden="true">→</span></a>
        
    </nav>


    

    
    <footer class="post-footer">
        <figure class="author-image">
            <a class="img" href="https://paper.seebug.org/users/author/?nickname=%E6%B7%B1%E4%BF%A1%E6%9C%8D%E5%8D%83%E9%87%8C%E7%9B%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C%E5%AE%A4" style="background-image: url(https://images.seebug.org/uploads/2021/09/v2-13dd83c1dd347405e946495a0aec7cd2_xl.jpeg)"><span class="hidden">'s Picture</span></a>r
        </figure>

        <section class="author">
            <h4><a href="https://paper.seebug.org/users/author/?nickname=%E6%B7%B1%E4%BF%A1%E6%9C%8D%E5%8D%83%E9%87%8C%E7%9B%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C%E5%AE%A4">深信服千里目安全实验室</a>
            </h4>
            <p class="author-desc"><span>深信服科技旗下安全实验室，致力于网络安全攻防技术的研究和积累，深度洞察未知网络安全威胁，解读前沿安全技术。</span></p>
            <p>阅读更多有关<a href="https://paper.seebug.org/users/author/?nickname=%E6%B7%B1%E4%BF%A1%E6%9C%8D%E5%8D%83%E9%87%8C%E7%9B%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C%E5%AE%A4">该作者</a>的文章
            </p>
            
            <div class="author-meta">
            </div>
        </section>


    </footer>
    
    
    <br>

    <section class="plugin_comment">
        <div class="error-box">

        </div>

        <!--评论表单 begin-->
        <form action="https://paper.seebug.org/1742/" class="comment-form" id="j-comment-form" data-vul-id="" style="margin-bottom: 20px;">
            <input type="hidden" name="csrfmiddlewaretoken" value="tAaxXcKDuWkvYzt7hkVn6XsfEkaDmS7E6gYuY4IkhGvJ46XPGTWSprU29oCcoaMR">
            <div class="row">
                <div class="col-md-offset-1">
                    <div class="col-md-5" style="margin-bottom: 20px">
                        <div class="input-group">
                            <span class="input-group-addon" id="basic-addon1">昵称</span>
                            <input type="text" class="form-control" placeholder="昵称(必填)" aria-describedby="basic-addon1" name="nickname" id="nickname">
                        </div>
                    </div>
                    <div class="col-md-6" style="margin-bottom: 20px">
                        <div class="input-group">
                            <span class="input-group-addon" id="basic-addon1">邮箱</span>
                            <input type="email" class="form-control" placeholder="邮箱(必填)" aria-describedby="basic-addon1" id="email" name="email">
                        </div>
                    </div>
                </div>
                <div class="col-md-1 hidden-xs">
                    <img src="./Pin 学习参考手册( See Bug 出品)_files/anonymous.jpg" alt="" class="avatar-b img-circle">
                </div>
                <div class="col-md-11">
                    <div class="input-group">
                                <textarea id="comment_content" cols="30" rows="10" style="resize: none" placeholder="请多说一点吧(10个字以上)" class="form-control"></textarea>
                        <span class="input-group-btn">
                    <button type="button" class="btn btn-brand-fill btn-submit-comment post-comment" name="post-comment" id="post-comment">提交评论</button>
                  </span>
                    </div>
                    <span style="color: red;font-size: 13px">* 注意:请正确填写邮箱，消息将通过邮箱通知！</span>
                </div>
            </div>
        </form>
        <!--评论表单 end-->
        
        <h4 style="font-weight: normal;font-size: 16px;padding-left: 20px;padding-bottom:20px;" id="comment-count">暂无评论</h4>
        
        <!--评论列表 begin-->
        <ul class="list-unstyled comment-list" id="j-comment-list">
            
        </ul>
        <!--评论列表 end-->

    </section>

</article>
<section class="plugin_feedback"></section>
<section class="back-top" id="backtop" style="display: block;">
    <div class="backtopFlxed new_backtop">
        <div class="back-top-font fa fa-angle-up">
        </div>
    </div>
</section>


  </div>
</main>
</div>

<script src="./Pin 学习参考手册( See Bug 出品)_files/gt.js.下载">
<script type="text/javascript" src="/static/vendors/bootstrap/dist/js/bootstrap.min.js"></script>
<script type="text/javascript" src="./Pin 学习参考手册( See Bug 出品)_files/jquery.fitvids.js.下载"></script>
<script type="text/javascript" src="./Pin 学习参考手册( See Bug 出品)_files/index.js.下载"></script>
<script type="text/javascript" src="./Pin 学习参考手册( See Bug 出品)_files/prism-loader.js.下载"></script>
<script type="text/javascript" src="./Pin 学习参考手册( See Bug 出品)_files/prism.js.下载"></script>
<script type="text/javascript" src="./Pin 学习参考手册( See Bug 出品)_files/jquery.ghostHunter.js.下载"></script>
<script type="text/javascript" src="./Pin 学习参考手册( See Bug 出品)_files/js.cookie.js.下载"></script>
<script type="text/javascript" src="./Pin 学习参考手册( See Bug 出品)_files/plugin_comment.js.下载"></script>
<script type="text/javascript" src="./Pin 学习参考手册( See Bug 出品)_files/custom.js.下载"></script>
<script type="text/javascript" src="./Pin 学习参考手册( See Bug 出品)_files/jweixin-1.6.0.js.下载"></script>
<script>
  wx.config({
    'appId': 'wx46c209f251516b33',
    'debug': 'False' !== 'False',
    'nonceStr': 'TX0HswJBoTvfw0H',
    'signature': 'd14f8640d8d4cbe550e6a02a275d3b3e9b17129c',
    'timestamp': '1677897194',
    'jsApiList': [
      
        'checkJsApi',
      
        'updateTimelineShareData',
      
        'updateAppMessageShareData',
      
    ],
  });
</script>


<script>
    wx.ready(function () {

        var title = '' || document.title;
        var link = window.location.href;
        var imgUrl = '' || 'https://paper.seebug.org' + '/static/images/weixin-share-seebug.jpg';
        var desc = '' || 'Seebug Paper 安全技术精粹';

        // “分享给朋友”及“分享到QQ”
        wx.updateAppMessageShareData({
            title: title, // 分享标题
            desc: desc, // 分享描述
            link: link, // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致
            imgUrl: imgUrl, // 分享图标
            success: function () {
                // 设置成功
            },
            cancel: function () {
                // 用户取消分享后执行的回调函数
            }
        });

        // “分享到朋友圈”及“分享到QQ空间”
        wx.updateTimelineShareData({
            title: title, // 分享标题
            link: link, // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致
            imgUrl: imgUrl, // 分享图标
            success: function () {
                // 设置成功
            },
            cancel: function () {
                // 用户取消分享后执行的回调函数
            }
        })


    })
</script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  config: ["MMLorHTML.js"],
  showMathMenu: false,
  jax: ["input/TeX", "output/HTML-CSS", "output/NativeMML"],
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
  extensions: ["MathMenu.js", "MathZoom.js"],
});




</script>





</body></html>